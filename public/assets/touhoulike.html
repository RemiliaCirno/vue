<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>弹幕天国 - HTML5弹幕射击游戏</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        
        #game-container {
            position: relative;
            width: 600px;
            height: 800px;
            border: 1px solid #333;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        
        #game-canvas {
            z-index: 1;
            background-color: #111;
        }
        
        #ui-canvas {
            z-index: 2;
            pointer-events: none;
        }
        
        #menu {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .menu-title {
            font-size: 48px;
            margin-bottom: 40px;
            color: #f0f0f0;
            text-shadow: 0 0 10px #88f, 0 0 20px #55f;
        }
        
        .menu-item {
            font-size: 24px;
            padding: 10px 20px;
            margin: 10px;
            background-color: #222;
            border: 1px solid #666;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .menu-item:hover {
            background-color: #444;
            transform: scale(1.1);
            box-shadow: 0 0 15px #88f;
        }
        
        #spell-announcement {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            color: white;
            text-shadow: 0 0 10px #f55, 0 0 20px #f22;
            opacity: 0;
            z-index: 3;
            transition: opacity 0.5s;
            text-align: center;
            pointer-events: none;
        }
        
        #stage-clear {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: gold;
            text-shadow: 0 0 10px #fa0, 0 0 20px #f60;
            opacity: 0;
            z-index: 3;
            transition: opacity 0.5s;
            text-align: center;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas" width="600" height="800"></canvas>
        <canvas id="ui-canvas" width="600" height="800"></canvas>
        <div id="spell-announcement"></div>
        <div id="stage-clear"></div>
        <div id="menu">
            <div class="menu-title">弹幕天国</div>
            <div class="menu-item" id="start-game">开始游戏</div>
            <div class="menu-item" id="select-character">选择角色</div>
            <div class="menu-item" id="practice-mode">练习模式</div>
            <div class="menu-item" id="spell-practice">符卡练习</div>
            <div class="menu-item" id="achievements">成就系统</div>
            <div class="menu-item" id="options">选项设置</div>
        </div>
    </div>

    <script>
        // 游戏主要变量
        const gameCanvas = document.getElementById('game-canvas');
        const gameCtx = gameCanvas.getContext('2d');
        const uiCanvas = document.getElementById('ui-canvas');
        const uiCtx = uiCanvas.getContext('2d');
        const menu = document.getElementById('menu');
        const spellAnnouncement = document.getElementById('spell-announcement');
        const stageClear = document.getElementById('stage-clear');
        
        // 游戏配置
        const CONFIG = {
            FPS: 60,
            PLAYER_SPEED: 5,
            PLAYER_FOCUS_SPEED: 2,
            PLAYER_SIZE: 5,
            PLAYER_HITBOX: 2,
            GRAZE_DISTANCE: 20,
            BULLET_SPEED: 5,
            BULLET_SIZE: 8,
            ENEMY_BULLET_SIZE: 8,
            ENEMY_SPEED: 3,
            ITEM_SPEED: 2,
            BOSS_HEALTH_MULTIPLIER: 400,
            SPELL_TIMEOUT: 30, // 秒
            STARTING_LIVES: 3,
            STARTING_BOMBS: 2,
            BOMB_RADIUS: 300,
            MAX_POWER: 4.0,
            POWER_STEP: 0.05,
            BULLET_CANCEL_SCORE: 100,
            ENEMY_KILL_SCORE: 500,
            GRAZE_SCORE: 50,
            SPELLCARD_BONUS: 5000,
            CAPTURE_BONUS: 10000,
            LIFE_BONUS: 50000,
            ITEM_COLLECT_RADIUS: 30,
            MAX_RANK: 100, // 难度排名系统
            BORDER_WIDTH: 20, // 游戏区域边界宽度
            REPLAY_FRAMES_INTERVAL: 5, // 每n帧记录一次回放数据
        };
        
        // 游戏状态
        const GAME_STATE = {
            isRunning: false,
            isPaused: false,
            isGameOver: false,
            currentStage: 0,
            difficulty: 'Normal',
            selectedCharacter: 0,
            mode: 'GAME', // GAME, PRACTICE, SPELL_PRACTICE
            score: 0,
            highScore: localStorage.getItem('highScore') || 0,
            graze: 0,
            power: 0,
            powerLevel: 0,
            lives: CONFIG.STARTING_LIVES,
            bombs: CONFIG.STARTING_BOMBS,
            rank: 0, // 动态难度系统
            pointValue: 10, // 基础点数价值
            combo: 0,
            maxCombo: 0,
            stageTimer: 0,
            bossTimer: 0,
            spellTimer: 0,
            practiceSpell: null,
            achievements: JSON.parse(localStorage.getItem('achievements')) || {},
            spellHistory: JSON.parse(localStorage.getItem('spellHistory')) || {},
            resources: {
                spirit: 0,
                faith: 0,
                magic: 0
            },
            replayData: [],
            replayMode: false,
            currentReplay: null,
            replayFrame: 0,
            specialMechanics: {
                bulletTime: false,
                shieldActive: false,
                perfectDodge: false,
                counterAttack: false,
                resonance: 0
            }
        };
        
        // 键盘输入
        const KEYS = {
            up: false,
            down: false,
            left: false,
            right: false,
            shoot: false,
            focus: false,
            bomb: false,
            special: false
        };
        
        // 游戏实体
        let player = null;
        let playerBullets = [];
        let enemies = [];
        let bosses = [];
        let enemyBullets = [];
        let items = [];
        let effects = [];
        
        // 角色类型定义
        const CHARACTERS = [
            {
                name: "灵梦",
                color: "#ff0000",
                shotType: "Homing",
                speed: 4.8,
                focusSpeed: 2.0,
                special: "结界",
                specialCost: 50,
                specialEffect: "屏幕清弹并短暂无敌",
                bombs: 3,
                bombType: "Fantasy Seal",
                uniqueMechanic: "灵力回收",
                uniqueAbility: "自动收集物品"
            },
            {
                name: "魔理沙",
                color: "#ffff00",
                shotType: "Laser",
                speed: 5.2,
                focusSpeed: 2.2,
                special: "魔法增幅",
                specialCost: 40,
                specialEffect: "火力全开，但消耗魔力",
                bombs: 2,
                bombType: "Master Spark",
                uniqueMechanic: "魔导书",
                uniqueAbility: "蓄力射击"
            },
            {
                name: "咲夜",
                color: "#aaaaff",
                shotType: "Spread",
                speed: 5.0,
                focusSpeed: 2.5,
                special: "时间操控",
                specialCost: 60,
                specialEffect: "短暂减慢子弹速度",
                bombs: 2,
                bombType: "Perfect Maid",
                uniqueMechanic: "时钟装置",
                uniqueAbility: "完美回避增加连击"
            }
        ];
        
        // 子弹类型
        const BULLET_TYPES = {
            PLAYER_NORMAL: 0,
            PLAYER_FOCUSED: 1,
            PLAYER_SPECIAL: 2,
            ENEMY_NORMAL: 3,
            ENEMY_LARGE: 4,
            ENEMY_SMALL: 5,
            ENEMY_LASER: 6,
            ENEMY_AIMED: 7,
            ENEMY_SPIRAL: 8,
            ENEMY_BOUNCE: 9,
            ENEMY_HOMING: 10,
            ENEMY_ACCELERATING: 11,
            ENEMY_DECELERATING: 12,
            ENEMY_CURVING: 13,
            ENEMY_SPELL: 14
        };
        
        // 物品类型
        const ITEM_TYPES = {
            POWER: 0,
            POINT: 1,
            LIFE: 2,
            BOMB: 3,
            SPIRIT: 4,
            FAITH: 5,
            MAGIC: 6,
            FULL_POWER: 7
        };
        
        // 效果类型
        const EFFECT_TYPES = {
            EXPLOSION: 0,
            HIT: 1,
            GRAZE: 2,
            POWERUP: 3,
            BONUS: 4,
            SPELL_START: 5,
            SPELL_END: 6,
            BOMB: 7
        };
        
        // 敌人类型
        const ENEMY_TYPES = {
            SMALL: 0,
            MEDIUM: 1,
            LARGE: 2,
            MINIBOSS: 3,
            BOSS: 4
        };
        
        // 关卡定义
        const STAGES = [
            {
                name: "Stage 1 - 迷雾森林",
                background: "#004400",
                music: "stage1",
                enemies: [
                    { type: ENEMY_TYPES.SMALL, count: 10, delay: 1, pattern: "line" },
                    { type: ENEMY_TYPES.MEDIUM, count: 5, delay: 5, pattern: "v" },
                    { type: ENEMY_TYPES.SMALL, count: 15, delay: 10, pattern: "circle" },
                    { type: ENEMY_TYPES.MEDIUM, count: 8, delay: 20, pattern: "random" },
                    { type: ENEMY_TYPES.LARGE, count: 3, delay: 35, pattern: "triangle" }
                ],
                boss: {
                    name: "露米娅",
                    title: "暗夜妖精",
                    health: 3,
                    spellCards: [
                        { name: "暗符「萤火微光」", health: 1, timeout: 30, bullets: [BULLET_TYPES.ENEMY_SPIRAL, BULLET_TYPES.ENEMY_SMALL] },
                        { name: "夜符「夜盲症」", health: 2, timeout: 40, bullets: [BULLET_TYPES.ENEMY_NORMAL, BULLET_TYPES.ENEMY_AIMED] },
                        { name: "暗符「永夜的降临」", health: 3, timeout: 60, bullets: [BULLET_TYPES.ENEMY_LARGE, BULLET_TYPES.ENEMY_SPIRAL, BULLET_TYPES.ENEMY_CURVING] }
                    ]
                },
                hazards: [
                    { type: "fog", delay: 15, duration: 10 },
                    { type: "wind", delay: 25, duration: 8, direction: "right" }
                ]
            },
            {
                name: "Stage 2 - 结冰湖泊",
                background: "#000066",
                music: "stage2",
                enemies: [
                    { type: ENEMY_TYPES.SMALL, count: 12, delay: 1, pattern: "wave" },
                    { type: ENEMY_TYPES.MEDIUM, count: 6, delay: 5, pattern: "cross" },
                    { type: ENEMY_TYPES.MEDIUM, count: 10, delay: 15, pattern: "spiral" },
                    { type: ENEMY_TYPES.LARGE, count: 4, delay: 25, pattern: "diamond" },
                    { type: ENEMY_TYPES.MINIBOSS, count: 1, delay: 40, pattern: "center" }
                ],
                boss: {
                    name: "琪露诺",
                    title: "冰之妖精",
                    health: 4,
                    spellCards: [
                        { name: "冰符「冷冻光线」", health: 1, timeout: 30, bullets: [BULLET_TYPES.ENEMY_LASER, BULLET_TYPES.ENEMY_SMALL] },
                        { name: "冰符「冰晶乱舞」", health: 2, timeout: 40, bullets: [BULLET_TYPES.ENEMY_BOUNCE, BULLET_TYPES.ENEMY_SMALL] },
                        { name: "雪符「钻石风暴」", health: 2, timeout: 45, bullets: [BULLET_TYPES.ENEMY_ACCELERATING, BULLET_TYPES.ENEMY_AIMED] },
                        { name: "「完美冻结」", health: 3, timeout: 60, bullets: [BULLET_TYPES.ENEMY_LARGE, BULLET_TYPES.ENEMY_BOUNCE, BULLET_TYPES.ENEMY_DECELERATING] }
                    ]
                },
                hazards: [
                    { type: "ice", delay: 10, duration: 15 },
                    { type: "blizzard", delay: 30, duration: 10 }
                ]
            },
            {
                name: "Stage 3 - 红魔馆",
                background: "#330000",
                music: "stage3",
                enemies: [
                    { type: ENEMY_TYPES.MEDIUM, count: 15, delay: 1, pattern: "formation" },
                    { type: ENEMY_TYPES.LARGE, count: 8, delay: 10, pattern: "square" },
                    { type: ENEMY_TYPES.MINIBOSS, count: 2, delay: 25, pattern: "diagonal" },
                    { type: ENEMY_TYPES.LARGE, count: 10, delay: 40, pattern: "circle" }
                ],
                boss: {
                    name: "蕾米莉亚",
                    title: "永远鲜红的幼月",
                    health: 5,
                    spellCards: [
                        { name: "红符「绯红之枪」", health: 2, timeout: 40, bullets: [BULLET_TYPES.ENEMY_LASER, BULLET_TYPES.ENEMY_AIMED] },
                        { name: "夜符「女王之夜」", health: 2, timeout: 45, bullets: [BULLET_TYPES.ENEMY_SPIRAL, BULLET_TYPES.ENEMY_HOMING] },
                        { name: "神鬼「蕾米莉亚斯托卡」", health: 3, timeout: 50, bullets: [BULLET_TYPES.ENEMY_LARGE, BULLET_TYPES.ENEMY_ACCELERATING] },
                        { name: "「红魔馆的破坏者」", health: 3, timeout: 60, bullets: [BULLET_TYPES.ENEMY_CURVING, BULLET_TYPES.ENEMY_BOUNCE, BULLET_TYPES.ENEMY_HOMING] },
                        { name: "「永夜蕾米莉亚」", health: 4, timeout: 75, bullets: [BULLET_TYPES.ENEMY_SPELL, BULLET_TYPES.ENEMY_LASER, BULLET_TYPES.ENEMY_SPIRAL, BULLET_TYPES.ENEMY_AIMED] }
                    ]
                },
                hazards: [
                    { type: "darkness", delay: 20, duration: 15 },
                    { type: "bats", delay: 35, duration: 10 }
                ]
            }
        ];
        
        // 符卡系统
        const SPELLCARDS = [];
        STAGES.forEach(stage => {
            if (stage.boss && stage.boss.spellCards) {
                stage.boss.spellCards.forEach(spell => {
                    SPELLCARDS.push({
                        name: spell.name,
                        boss: stage.boss.name,
                        stage: stage.name,
                        health: spell.health,
                        timeout: spell.timeout,
                        bullets: spell.bullets
                    });
                });
            }
        });
        
        // 成就系统
        const ACHIEVEMENTS = [
            { id: "first_clear", name: "初次通关", description: "第一次完成游戏" },
            { id: "perfect_spell", name: "完美击破", description: "不受伤击破一张符卡" },
            { id: "1cc", name: "一命通关", description: "不损失生命通关" },
            { id: "graze_master", name: "擦弹大师", description: "单局擦弹数超过1000" },
            { id: "spell_collector", name: "符卡收集者", description: "收集所有符卡" },
            { id: "high_score", name: "高分达人", description: "获得100万分以上" },
            { id: "no_bomb", name: "无炸无伤", description: "不使用炸弹且不受伤通关" },
            { id: "max_power", name: "全力全开", description: "达到最大火力并维持一整关" },
            { id: "perfect_dodge", name: "完美回避", description: "在弹幕密集处连续擦弹30次" },
            { id: "combo_king", name: "连击之王", description: "达成100连击" }
        ];
        
        // 初始化成就
        ACHIEVEMENTS.forEach(achievement => {
            if (!GAME_STATE.achievements[achievement.id]) {
                GAME_STATE.achievements[achievement.id] = { 
                    unlocked: false, 
                    progress: 0, 
                    date: null 
                };
            }
        });
        
        // 玩家类
        class Player {
            constructor(character) {
                this.x = gameCanvas.width / 2;
                this.y = gameCanvas.height - 100;
                this.width = CONFIG.PLAYER_SIZE * 2;
                this.height = CONFIG.PLAYER_SIZE * 2;
                this.hitboxRadius = CONFIG.PLAYER_HITBOX;
                this.speed = CHARACTERS[character].speed;
                this.focusSpeed = CHARACTERS[character].focusSpeed;
                this.character = character;
                this.isFocused = false;
                this.isInvincible = false;
                this.invincibleTime = 0;
                this.shootCooldown = 0;
                this.bombCooldown = 0;
                this.specialCooldown = 0;
                this.shotType = CHARACTERS[character].shotType;
                this.animation = 0;
                this.options = []; // 选项（跟随玩家的辅助发射器）
                this.updateOptions();
                this.autoCollectRadius = character === 0 ? CONFIG.ITEM_COLLECT_RADIUS * 2 : CONFIG.ITEM_COLLECT_RADIUS;
                this.uniqueMechanicValue = 0; // 角色特殊机制的值
                this.uniqueMechanicActive = false;
                this.lastPosition = { x: this.x, y: this.y }; // 用于检测移动
                this.perfectDodgeCounter = 0; // 完美回避计数器
            }
            
            update() {
                this.lastPosition = { x: this.x, y: this.y };
                
                // 移动逻辑
                let moveSpeed = this.isFocused ? this.focusSpeed : this.speed;
                
                if (KEYS.up) this.y -= moveSpeed;
                if (KEYS.down) this.y += moveSpeed;
                if (KEYS.left) this.x -= moveSpeed;
                if (KEYS.right) this.x += moveSpeed;
                
                // 边界检查
                this.x = Math.max(CONFIG.BORDER_WIDTH, Math.min(gameCanvas.width - CONFIG.BORDER_WIDTH, this.x));
                this.y = Math.max(CONFIG.BORDER_WIDTH, Math.min(gameCanvas.height - CONFIG.BORDER_WIDTH, this.y));
                
                // 射击逻辑
                if (KEYS.shoot && this.shootCooldown <= 0) {
                    this.shoot();
                    this.shootCooldown = this.isFocused ? 8 : 5;
                }
                
                if (this.shootCooldown > 0) {
                    this.shootCooldown--;
                }
                
                // 炸弹逻辑
                if (KEYS.bomb && this.bombCooldown <= 0 && GAME_STATE.bombs > 0) {
                    this.useBomb();
                    this.bombCooldown = 120; // 2秒冷却
                    GAME_STATE.bombs--;
                }
                
                if (this.bombCooldown > 0) {
                    this.bombCooldown--;
                }
                
                // 特殊能力逻辑
                if (KEYS.special && this.specialCooldown <= 0) {
                    this.useSpecial();
                    this.specialCooldown = 180; // 3秒冷却
                }
                
                if (this.specialCooldown > 0) {
                    this.specialCooldown--;
                }
                
                // 无敌时间逻辑
                if (this.isInvincible) {
                    this.invincibleTime--;
                    if (this.invincibleTime <= 0) {
                        this.isInvincible = false;
                    }
                }
                
                // 角色特殊机制更新
                this.updateUniqueMechanic();
                
                // 跟随选项更新
                this.updateOptions();
                
                // 动画帧更新
                this.animation = (this.animation + 1) % 60;
                
                // 自动收集物品（灵梦特性）
                if (this.character === 0) {
                    this.autoCollectItems();
                }
                
                // 完美回避检测
                if (this.hasMoved() && this.checkNearbyBullets()) {
                    this.perfectDodgeCounter++;
                    if (this.perfectDodgeCounter >= 30) {
                        this.triggerPerfectDodge();
                        this.perfectDodgeCounter = 0;
                    }
                } else {
                    this.perfectDodgeCounter = Math.max(0, this.perfectDodgeCounter - 1);
                }
            }
            
            hasMoved() {
                return this.lastPosition.x !== this.x || this.lastPosition.y !== this.y;
            }
            
            checkNearbyBullets() {
                // 检查半径为graze距离内的子弹数量
                const nearbyBullets = enemyBullets.filter(bullet => {
                    const dx = this.x - bullet.x;
                    const dy = this.y - bullet.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance < CONFIG.GRAZE_DISTANCE * 1.5;
                });
                
                return nearbyBullets.length >= 10; // 如果有10个以上子弹在附近
            }
            
            triggerPerfectDodge() {
                // 触发完美回避效果
                GAME_STATE.specialMechanics.perfectDodge = true;
                this.isInvincible = true;
                this.invincibleTime = 60;
                
                // 添加视觉效果
                effects.push(new Effect(this.x, this.y, EFFECT_TYPES.POWERUP, 60));
                
                // 获得奖励
                GAME_STATE.score += 10000;
                
                // 如果是咲夜，增加连击
                if (this.character === 2) {
                    GAME_STATE.combo += 10;
                    GAME_STATE.maxCombo = Math.max(GAME_STATE.combo, GAME_STATE.maxCombo);
                }
                
                setTimeout(() => {
                    GAME_STATE.specialMechanics.perfectDodge = false;
                }, 1000);
            }
            
            updateUniqueMechanic() {
                // 根据角色类型更新特殊机制
                switch(this.character) {
                    case 0: // 灵梦 - 灵力回收
                        if (this.isFocused) {
                            this.uniqueMechanicValue += 0.1;
                            if (this.uniqueMechanicValue >= 100) {
                                this.uniqueMechanicValue = 0;
                                GAME_STATE.resources.spirit += 1;
                            }
                        }
                        break;
                    case 1: // 魔理沙 - 魔导书
                        if (KEYS.shoot && this.isFocused) {
                            this.uniqueMechanicValue = Math.min(100, this.uniqueMechanicValue + 0.5);
                        } else {
                            this.uniqueMechanicValue = Math.max(0, this.uniqueMechanicValue - 1);
                        }
                        break;
                    case 2: // 咲夜 - 时钟装置
                        if (this.uniqueMechanicActive) {
                            this.uniqueMechanicValue--;
                            if (this.uniqueMechanicValue <= 0) {
                                this.uniqueMechanicActive = false;
                                GAME_STATE.specialMechanics.bulletTime = false;
                            }
                        } else {
                            this.uniqueMechanicValue = Math.min(100, this.uniqueMechanicValue + 0.1);
                        }
                        break;
                }
            }
            
            autoCollectItems() {
                items.forEach(item => {
                    const dx = this.x - item.x;
                    const dy = this.y - item.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < this.autoCollectRadius) {
                        // 将物品移向玩家
                        const angle = Math.atan2(dy, dx);
                        item.x += Math.cos(angle) * 5;
                        item.y += Math.sin(angle) * 5;
                    }
                });
            }
            
            updateOptions() {
                // 根据火力等级更新选项数量
                const optionCount = Math.floor(GAME_STATE.powerLevel);
                
                // 如果需要添加新选项
                while (this.options.length < optionCount && this.options.length < 4) {
                    // 基于角色类型创建不同的选项配置
                    let optionConfig;
                    switch(this.character) {
                        case 0: // 灵梦
                            optionConfig = {
                                offsetX: (this.options.length % 2 === 0) ? 20 : -20,
                                offsetY: -15 - (this.options.length * 5),
                                fireAngle: 0,
                                fireDelay: this.options.length * 2
                            };
                            break;
                        case 1: // 魔理沙
                            optionConfig = {
                                offsetX: (this.options.length % 2 === 0) ? 15 : -15,
                                offsetY: -10,
                                fireAngle: (this.options.length % 2 === 0) ? -15 : 15,
                                fireDelay: this.options.length * 3
                            };
                            break;
                        case 2: // 咲夜
                            optionConfig = {
                                offsetX: (this.options.length * 10) - 15,
                                offsetY: -5,
                                fireAngle: 0,
                                fireDelay: this.options.length * 4
                            };
                            break;
                    }
                    
                    this.options.push(optionConfig);
                }
                
                // 如果需要移除选项
                while (this.options.length > optionCount) {
                    this.options.pop();
                }
            }
            
            shoot() {
                // 根据角色和聚焦状态创建不同的子弹模式
                switch(this.character) {
                    case 0: // 灵梦
                        if (this.isFocused) {
                            // 聚焦射击 - 直线追踪弹
                            playerBullets.push(new Bullet(
                                this.x, this.y - 10,
                                0, -10,
                                BULLET_TYPES.PLAYER_FOCUSED,
                                10, 20, "#ff88ff"
                            ));
                        } else {
                            // 普通射击 - 扩散弹
                            playerBullets.push(new Bullet(
                                this.x - 10, this.y,
                                -0.5, -9,
                                BULLET_TYPES.PLAYER_NORMAL,
                                6, 12, "#ff0000"
                            ));
                            playerBullets.push(new Bullet(
                                this.x, this.y - 10,
                                0, -10,
                                BULLET_TYPES.PLAYER_NORMAL,
                                6, 12, "#ff0000"
                            ));
                            playerBullets.push(new Bullet(
                                this.x + 10, this.y,
                                0.5, -9,
                                BULLET_TYPES.PLAYER_NORMAL,
                                6, 12, "#ff0000"
                            ));
                        }
                        break;
                        
                    case 1: // 魔理沙
                        if (this.isFocused) {
                            // 聚焦射击 - 激光
                            const power = this.uniqueMechanicValue / 50;
                            playerBullets.push(new Bullet(
                                this.x, this.y - 10,
                                0, -12,
                                BULLET_TYPES.PLAYER_FOCUSED,
                                8 + power * 4, 25 + power * 10, "#ffff00"
                            ));
                        } else {
                            // 普通射击 - 星形弹
                            playerBullets.push(new Bullet(
                                this.x - 15, this.y,
                                -1, -8,
                                BULLET_TYPES.PLAYER_NORMAL,
                                7, 14, "#ffaa00"
                            ));
                            playerBullets.push(new Bullet(
                                this.x, this.y - 10,
                                0, -9,
                                BULLET_TYPES.PLAYER_NORMAL,
                                7, 14, "#ffaa00"
                            ));
                            playerBullets.push(new Bullet(
                                this.x + 15, this.y,
                                1, -8,
                                BULLET_TYPES.PLAYER_NORMAL,
                                7, 14, "#ffaa00"
                            ));
                        }
                        break;
                        
                    case 2: // 咲夜
                        if (this.isFocused) {
                            // 聚焦射击 - 飞刀阵列
                            for (let i = -2; i <= 2; i++) {
                                playerBullets.push(new Bullet(
                                    this.x, this.y - 10,
                                    i, -10,
                                    BULLET_TYPES.PLAYER_FOCUSED,
                                    5, 15, "#aaaaff"
                                ));
                            }
                        } else {
                            // 普通射击 - 飞刀扇形
                            for (let i = -1; i <= 1; i++) {
                                playerBullets.push(new Bullet(
                                    this.x, this.y - 10,
                                    i * 2, -8,
                                    BULLET_TYPES.PLAYER_NORMAL,
                                    6, 12, "#8888ff"
                                ));
                            }
                        }
                        break;
                }
                
                // 选项射击
                this.options.forEach((option, index) => {
                    if ((GAME_STATE.stageTimer + option.fireDelay) % 10 === 0) {
                        const bulletType = this.isFocused ? BULLET_TYPES.PLAYER_FOCUSED : BULLET_TYPES.PLAYER_NORMAL;
                        const angle = option.fireAngle * (Math.PI / 180);
                        const speed = this.isFocused ? 12 : 9;
                        const vx = Math.sin(angle) * speed;
                        const vy = -Math.cos(angle) * speed;
                        
                        playerBullets.push(new Bullet(
                            this.x + option.offsetX,
                            this.y + option.offsetY,
                            vx, vy,
                            bulletType,
                            5, 10,
                            this.isFocused ? "#ffffff" : CHARACTERS[this.character].color
                        ));
                    }
                });
            }
            
            useBomb() {
                this.isInvincible = true;
                this.invincibleTime = 180; // 3秒无敌
                
                // 创建炸弹效果
                effects.push(new Effect(this.x, this.y, EFFECT_TYPES.BOMB, 120));
                
                // 根据角色类型创建不同的炸弹效果
                switch(this.character) {
                    case 0: // 灵梦 - Fantasy Seal
                        // 清除屏幕上所有敌人子弹
                        const clearedBullets = enemyBullets.length;
                        enemyBullets = [];
                        
                        // 对所有敌人造成伤害
                        enemies.forEach(enemy => {
                            enemy.health -= 50;
                        });
                        
                        bosses.forEach(boss => {
                            boss.health -= 100;
                        });
                        
                        // 根据清除的子弹数量获得分数
                        GAME_STATE.score += clearedBullets * CONFIG.BULLET_CANCEL_SCORE;
                        break;
                        
                    case 1: // 魔理沙 - Master Spark
                        // 创建一个大型激光效果
                        for (let i = 0; i < 30; i++) {
                            setTimeout(() => {
                                // 在屏幕中央创建一个向上的大型激光
                                playerBullets.push(new Bullet(
                                    this.x, this.y,
                                    0, -20,
                                    BULLET_TYPES.PLAYER_SPECIAL,
                                    50, 800, "#ffff88"
                                ));
                            }, i * 50);
                        }
                        break;
                        
                    case 2: // 咲夜 - Perfect Maid
                        // 时间停止效果
                        GAME_STATE.specialMechanics.bulletTime = true;
                        
                        // 创建围绕玩家的飞刀
                        for (let i = 0; i < 16; i++) {
                            const angle = (i / 16) * Math.PI * 2;
                            playerBullets.push(new Bullet(
                                this.x, this.y,
                                Math.cos(angle) * 3,
                                Math.sin(angle) * 3,
                                BULLET_TYPES.PLAYER_SPECIAL,
                                8, 16, "#aaaaff"
                            ));
                        }
                        
                        // 3秒后解除时间停止
                        setTimeout(() => {
                            GAME_STATE.specialMechanics.bulletTime = false;
                        }, 3000);
                        break;
                }
            }
            
            useSpecial() {
                // 检查资源是否足够
                const specialCost = CHARACTERS[this.character].specialCost;
                
                switch(this.character) {
                    case 0: // 灵梦 - 结界
                        if (GAME_STATE.resources.spirit >= specialCost) {
                            GAME_STATE.resources.spirit -= specialCost;
                            
                            // 创建结界效果
                            GAME_STATE.specialMechanics.shieldActive = true;
                            this.isInvincible = true;
                            this.invincibleTime = 300; // 5秒无敌
                            
                            // 添加视觉效果
                            effects.push(new Effect(this.x, this.y, EFFECT_TYPES.SPELL_START, 60));
                            
                            // 5秒后结束
                            setTimeout(() => {
                                GAME_STATE.specialMechanics.shieldActive = false;
                            }, 5000);
                        }
                        break;
                        
                    case 1: // 魔理沙 - 魔法增幅
                        if (GAME_STATE.resources.magic >= specialCost) {
                            GAME_STATE.resources.magic -= specialCost;
                            
                            // 激活魔法增幅状态
                            this.uniqueMechanicActive = true;
                            
                            // 增加火力
                            const originalPower = GAME_STATE.power;
                            GAME_STATE.power = CONFIG.MAX_POWER;
                            GAME_STATE.powerLevel = Math.floor(GAME_STATE.power);
                            
                            // 添加视觉效果
                            effects.push(new Effect(this.x, this.y, EFFECT_TYPES.POWERUP, 60));
                            
                            // 10秒后恢复原始火力
                            setTimeout(() => {
                                this.uniqueMechanicActive = false;
                                GAME_STATE.power = originalPower;
                                GAME_STATE.powerLevel = Math.floor(GAME_STATE.power);
                            }, 10000);
                        }
                        break;
                        
                    case 2: // 咲夜 - 时间操控
                        if (GAME_STATE.resources.faith >= specialCost) {
                            GAME_STATE.resources.faith -= specialCost;
                            
                            // 激活时间操控
                            this.uniqueMechanicActive = true;
                            this.uniqueMechanicValue = 100;
                            GAME_STATE.specialMechanics.bulletTime = true;
                            
                            // 添加视觉效果
                            effects.push(new Effect(this.x, this.y, EFFECT_TYPES.SPELL_START, 60));
                        }
                        break;
                }
            }
            
            draw() {
                // 绘制玩家
                gameCtx.save();
                
                // 无敌状态闪烁
                if (!this.isInvincible || Math.floor(this.invincibleTime / 5) % 2 === 0) {
                    // 绘制角色
                    gameCtx.fillStyle = CHARACTERS[this.character].color;
                    gameCtx.beginPath();
                    gameCtx.arc(this.x, this.y, CONFIG.PLAYER_SIZE, 0, Math.PI * 2);
                    gameCtx.fill();
                    
                    // 聚焦状态显示准心
                    if (this.isFocused) {
                        gameCtx.strokeStyle = "#ffffff";
                        gameCtx.beginPath();
                        gameCtx.arc(this.x, this.y, CONFIG.PLAYER_HITBOX, 0, Math.PI * 2);
                        gameCtx.stroke();
                    }
                    
                    // 绘制选项（辅助发射器）
                    this.options.forEach(option => {
                        gameCtx.fillStyle = "#ffffff";
                        gameCtx.globalAlpha = 0.7;
                        gameCtx.beginPath();
                        gameCtx.arc(
                            this.x + option.offsetX, 
                            this.y + option.offsetY, 
                            3, 0, Math.PI * 2
                        );
                        gameCtx.fill();
                    });
                    
                    // 绘制特殊能力效果
                    if (GAME_STATE.specialMechanics.shieldActive) {
                        // 灵梦的结界
                        gameCtx.strokeStyle = "#ff88ff";
                        gameCtx.globalAlpha = 0.5 + 0.3 * Math.sin(this.animation * 0.1);
                        gameCtx.beginPath();
                        gameCtx.arc(this.x, this.y, 30, 0, Math.PI * 2);
                        gameCtx.stroke();
                    }
                    
                    if (this.uniqueMechanicActive && this.character === 1) {
                        // 魔理沙的魔法增幅
                        gameCtx.fillStyle = "#ffff00";
                        gameCtx.globalAlpha = 0.3;
                        for (let i = 0; i < 8; i++) {
                            const angle = (this.animation * 0.05) + (i / 8) * Math.PI * 2;
                            const orbitRadius = 20;
                            gameCtx.beginPath();
                            gameCtx.arc(
                                this.x + Math.cos(angle) * orbitRadius,
                                this.y + Math.sin(angle) * orbitRadius,
                                2, 0, Math.PI * 2
                            );
                            gameCtx.fill();
                        }
                    }
                    
                    if (GAME_STATE.specialMechanics.perfectDodge) {
                        // 完美回避效果
                        gameCtx.strokeStyle = "#88ffff";
                        gameCtx.globalAlpha = 0.7;
                        gameCtx.beginPath();
                        gameCtx.arc(this.x, this.y, 25, 0, Math.PI * 2);
                        gameCtx.stroke();
                    }
                }
                
                gameCtx.restore();
            }
            
            checkCollision(bullet) {
                if (this.isInvincible) return false;
                
                const dx = this.x - bullet.x;
                const dy = this.y - bullet.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // 检查擦弹
                if (distance < CONFIG.GRAZE_DISTANCE && !bullet.grazed) {
                    bullet.grazed = true;
                    GAME_STATE.graze++;
                    GAME_STATE.score += CONFIG.GRAZE_SCORE;
                    GAME_STATE.pointValue = Math.min(GAME_STATE.pointValue + 1, 100);
                    
                    // 添加擦弹效果
                    effects.push(new Effect(bullet.x, bullet.y, EFFECT_TYPES.GRAZE, 20));
                    
                    // 增加特殊资源
                    switch(this.character) {
                        case 0: // 灵梦
                            GAME_STATE.resources.spirit += 0.5;
                            break;
                        case 1: // 魔理沙
                            GAME_STATE.resources.magic += 0.3;
                            break;
                        case 2: // 咲夜
                            GAME_STATE.resources.faith += 0.4;
                            break;
                    }
                    
                    // 增加连击
                    GAME_STATE.combo++;
                    GAME_STATE.maxCombo = Math.max(GAME_STATE.combo, GAME_STATE.maxCombo);
                    
                    // 检查完美回避成就
                    if (GAME_STATE.graze % 100 === 0) {
                        checkAchievement("perfect_dodge", 1);
                    }
                }
                
                // 检查碰撞
                return distance < this.hitboxRadius + bullet.radius;
            }
            
            hit() {
                if (this.isInvincible) return;
                
                // 受伤效果
                this.isInvincible = true;
                this.invincibleTime = 180; // 3秒无敌
                
                GAME_STATE.lives--;
                GAME_STATE.power = Math.max(1.0, GAME_STATE.power - 1.0);
                GAME_STATE.powerLevel = Math.floor(GAME_STATE.power);
                GAME_STATE.combo = 0;
                
                // 死亡时掉落物品
                for (let i = 0; i < 5; i++) {
                    items.push(new Item(
                        this.x, this.y,
                        Math.random() * 4 - 2,
                        -3 + Math.random() * 2,
                        ITEM_TYPES.POWER
                    ));
                }
                
                // 检查游戏结束
                if (GAME_STATE.lives <= 0) {
                    gameOver();
                }
                
                // 添加爆炸效果
                effects.push(new Effect(this.x, this.y, EFFECT_TYPES.EXPLOSION, 60));
                
                // 清除附近的子弹
                enemyBullets = enemyBullets.filter(bullet => {
                    const dx = this.x - bullet.x;
                    const dy = this.y - bullet.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance > 50;
                });
            }
        }
        
        // 子弹类
        class Bullet {
            constructor(x, y, vx, vy, type, radius, damage, color) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.type = type;
                this.radius = radius;
                this.damage = damage;
                this.color = color;
                this.grazed = false;
                this.lifetime = 0;
                this.target = null; // 用于追踪弹
                this.acceleration = 0; // 用于加速/减速弹
                this.angle = Math.atan2(vy, vx); // 用于旋转/螺旋弹
                this.angleSpeed = 0; // 角速度，用于曲线弹
                this.bounceCount = 0; // 反弹次数，用于反弹弹
                this.maxBounces = 3; // 最大反弹次数
                this.spellEffects = []; // 用于符卡特效
            }
            
            update() {
                this.lifetime++;
                
                // 根据子弹类型更新运动
                switch(this.type) {
                    case BULLET_TYPES.PLAYER_NORMAL:
                    case BULLET_TYPES.PLAYER_FOCUSED:
                    case BULLET_TYPES.PLAYER_SPECIAL:
                    case BULLET_TYPES.ENEMY_NORMAL:
                    case BULLET_TYPES.ENEMY_LARGE:
                    case BULLET_TYPES.ENEMY_SMALL:
                        // 标准直线运动
                        this.x += this.vx;
                        this.y += this.vy;
                        break;
                        
                    case BULLET_TYPES.ENEMY_LASER:
                        // 激光效果 - 延长射程
                        this.radius = Math.min(this.radius + 1, 800);
                        this.x += this.vx;
                        this.y += this.vy;
                        break;
                        
                    case BULLET_TYPES.ENEMY_AIMED:
                        // 瞄准玩家的子弹
                        if (this.lifetime < 30 && player) {
                            const dx = player.x - this.x;
                            const dy = player.y - this.y;
                            const angle = Math.atan2(dy, dx);
                            this.vx = Math.cos(angle) * CONFIG.BULLET_SPEED;
                            this.vy = Math.sin(angle) * CONFIG.BULLET_SPEED;
                        }
                        this.x += this.vx;
                        this.y += this.vy;
                        break;
                        
                    case BULLET_TYPES.ENEMY_SPIRAL:
                        // 螺旋弹
                        this.angle += 0.05;
                        const speed = CONFIG.BULLET_SPEED * 0.8;
                        this.vx = Math.cos(this.angle) * speed;
                        this.vy = Math.sin(this.angle) * speed;
                        this.x += this.vx;
                        this.y += this.vy;
                        break;
                        
                    case BULLET_TYPES.ENEMY_BOUNCE:
                        // 反弹弹
                        this.x += this.vx;
                        this.y += this.vy;
                        
                        // 检查边界反弹
                        if (this.x < CONFIG.BORDER_WIDTH || this.x > gameCanvas.width - CONFIG.BORDER_WIDTH) {
                            this.vx = -this.vx;
                            this.bounceCount++;
                        }
                        
                        if (this.y < CONFIG.BORDER_WIDTH || this.y > gameCanvas.height - CONFIG.BORDER_WIDTH) {
                            this.vy = -this.vy;
                            this.bounceCount++;
                        }
                        break;
                        
                    case BULLET_TYPES.ENEMY_HOMING:
                        // 追踪弹
                        if (player) {
                            const dx = player.x - this.x;
                            const dy = player.y - this.y;
                            const angle = Math.atan2(dy, dx);
                            
                            // 缓慢调整方向
                            const turnSpeed = 0.03;
                            const currentAngle = Math.atan2(this.vy, this.vx);
                            let newAngle = currentAngle;
                            
                            // 计算最短角度调整
                            let angleDiff = angle - currentAngle;
                            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                            
                            if (Math.abs(angleDiff) < turnSpeed) {
                                newAngle = angle;
                            } else if (angleDiff > 0) {
                                newAngle += turnSpeed;
                            } else {
                                newAngle -= turnSpeed;
                            }
                            
                            const speed = CONFIG.BULLET_SPEED * 0.7;
                            this.vx = Math.cos(newAngle) * speed;
                            this.vy = Math.sin(newAngle) * speed;
                        }
                        
                        this.x += this.vx;
                        this.y += this.vy;
                        break;
                        
                    case BULLET_TYPES.ENEMY_ACCELERATING:
                        // 加速弹
                        this.vx *= 1.03;
                        this.vy *= 1.03;
                        this.x += this.vx;
                        this.y += this.vy;
                        break;
                        
                    case BULLET_TYPES.ENEMY_DECELERATING:
                        // 减速弹
                        this.vx *= 0.97;
                        this.vy *= 0.97;
                        this.x += this.vx;
                        this.y += this.vy;
                        break;
                        
                    case BULLET_TYPES.ENEMY_CURVING:
                        // 曲线弹
                        this.angleSpeed += 0.001;
                        this.angle += this.angleSpeed;
                        const curveSpeed = CONFIG.BULLET_SPEED * 0.9;
                        this.vx = Math.cos(this.angle) * curveSpeed;
                        this.vy = Math.sin(this.angle) * curveSpeed;
                        this.x += this.vx;
                        this.y += this.vy;
                        break;
                        
                    case BULLET_TYPES.ENEMY_SPELL:
                        // 符卡特效子弹 - 复杂的运动模式和视觉效果
                        // 随时间变化形状和颜色
                        const t = this.lifetime * 0.05;
                        const oscillation = Math.sin(t) * 10;
                        
                        this.x += this.vx + Math.cos(t * 2) * 2;
                        this.y += this.vy + Math.sin(t * 3) * 2;
                        
                        // 添加粒子效果
                        if (this.lifetime % 5 === 0) {
                            this.spellEffects.push({
                                x: this.x,
                                y: this.y,
                                size: this.radius * 0.5,
                                life: 20
                            });
                        }
                        
                        // 更新粒子效果
                        this.spellEffects = this.spellEffects.filter(effect => {
                            effect.life--;
                            return effect.life > 0;
                        });
                        break;
                }
                
                // 时间减速效果 (bullet time)
                if (GAME_STATE.specialMechanics.bulletTime && 
                    (this.type === BULLET_TYPES.ENEMY_NORMAL ||
                     this.type === BULLET_TYPES.ENEMY_LARGE ||
                     this.type === BULLET_TYPES.ENEMY_SMALL ||
                     this.type === BULLET_TYPES.ENEMY_AIMED ||
                     this.type === BULLET_TYPES.ENEMY_SPIRAL ||
                     this.type === BULLET_TYPES.ENEMY_BOUNCE ||
                     this.type === BULLET_TYPES.ENEMY_HOMING ||
                     this.type === BULLET_TYPES.ENEMY_ACCELERATING ||
                     this.type === BULLET_TYPES.ENEMY_DECELERATING ||
                     this.type === BULLET_TYPES.ENEMY_CURVING ||
                     this.type === BULLET_TYPES.ENEMY_SPELL)) {
                    
                    this.x -= this.vx * 0.7; // 减慢70%的速度
                    this.y -= this.vy * 0.7;
                }
                
                // 检查边界 - 超出屏幕则移除
                return this.isOutOfBounds() || (this.type === BULLET_TYPES.ENEMY_BOUNCE && this.bounceCount > this.maxBounces);
            }
            
            isOutOfBounds() {
                const margin = 50; // 允许子弹稍微超出边界
                return (
                    this.x < -margin ||
                    this.x > gameCanvas.width + margin ||
                    this.y < -margin ||
                    this.y > gameCanvas.height + margin
                );
            }
            
            draw() {
                gameCtx.save();
                
                switch(this.type) {
                    case BULLET_TYPES.PLAYER_NORMAL:
                        // 普通玩家子弹
                        gameCtx.fillStyle = this.color;
                        gameCtx.beginPath();
                        gameCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        gameCtx.fill();
                        break;
                        
                    case BULLET_TYPES.PLAYER_FOCUSED:
                        // 聚焦玩家子弹
                        gameCtx.fillStyle = this.color;
                        gameCtx.beginPath();
                        gameCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        gameCtx.fill();
                        
                        // 添加光晕效果
                        gameCtx.globalAlpha = 0.3;
                        gameCtx.beginPath();
                        gameCtx.arc(this.x, this.y, this.radius * 1.5, 0, Math.PI * 2);
                        gameCtx.fill();
                        break;
                        
                    case BULLET_TYPES.PLAYER_SPECIAL:
                        // 特殊玩家子弹 (炸弹/特殊能力)
                        gameCtx.fillStyle = this.color;
                        
                        // 随时间脉动的效果
                        const pulseSize = this.radius * (1 + 0.2 * Math.sin(this.lifetime * 0.2));
                        
                        gameCtx.beginPath();
                        gameCtx.arc(this.x, this.y, pulseSize, 0, Math.PI * 2);
                        gameCtx.fill();
                        
                        // 添加光晕效果
                        gameCtx.globalAlpha = 0.5;
                        gameCtx.beginPath();
                        gameCtx.arc(this.x, this.y, pulseSize * 1.5, 0, Math.PI * 2);
                        gameCtx.fill();
                        break;
                        
                    case BULLET_TYPES.ENEMY_NORMAL:
                        // 普通敌人子弹
                        gameCtx.fillStyle = this.color;
                        gameCtx.beginPath();
                        gameCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        gameCtx.fill();
                        break;
                        
                    case BULLET_TYPES.ENEMY_LARGE:
                        // 大型敌人子弹
                        gameCtx.fillStyle = this.color;
                        gameCtx.beginPath();
                        gameCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        gameCtx.fill();
                        
                        // 添加边缘
                        gameCtx.strokeStyle = "#ffffff";
                        gameCtx.lineWidth = 2;
                        gameCtx.beginPath();
                        gameCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        gameCtx.stroke();
                        break;
                        
                    case BULLET_TYPES.ENEMY_SMALL:
                        // 小型敌人子弹
                        gameCtx.fillStyle = this.color;
                        
                        // 绘制菱形
                        gameCtx.beginPath();
                        gameCtx.moveTo(this.x, this.y - this.radius);
                        gameCtx.lineTo(this.x + this.radius, this.y);
                        gameCtx.lineTo(this.x, this.y + this.radius);
                        gameCtx.lineTo(this.x - this.radius, this.y);
                        gameCtx.closePath();
                        gameCtx.fill();
                        break;
                        
                    case BULLET_TYPES.ENEMY_LASER:
                        // 激光
                        const angle = Math.atan2(this.vy, this.vx);
                        
                        // 绘制激光光束
                        gameCtx.save();
                        gameCtx.translate(this.x, this.y);
                        gameCtx.rotate(angle);
                        
                        // 内部光束
                        gameCtx.fillStyle = "#ffffff";
                        gameCtx.fillRect(0, -this.radius / 4, this.radius, this.radius / 2);
                        
                        // 外部光晕
                        gameCtx.globalAlpha = 0.3;
                        gameCtx.fillStyle = this.color;
                        gameCtx.fillRect(0, -this.radius / 2, this.radius, this.radius);
                        
                        gameCtx.restore();
                        break;
                        
                    case BULLET_TYPES.ENEMY_AIMED:
                        // 瞄准型子弹
                        gameCtx.fillStyle = this.color;
                        
                        // 绘制箭头形状
                        const aimAngle = Math.atan2(this.vy, this.vx);
                        
                        gameCtx.save();
                        gameCtx.translate(this.x, this.y);
                        gameCtx.rotate(aimAngle);
                        
                        gameCtx.beginPath();
                        gameCtx.moveTo(this.radius, 0);
                        gameCtx.lineTo(-this.radius/2, this.radius/2);
                        gameCtx.lineTo(-this.radius/2, -this.radius/2);
                        gameCtx.closePath();
                        gameCtx.fill();
                        
                        gameCtx.restore();
                        break;
                        
                    case BULLET_TYPES.ENEMY_SPIRAL:
                        // 螺旋弹
                        gameCtx.fillStyle = this.color;
                        
                        // 绘制旋转的星形
                        const spiralAngle = this.lifetime * 0.1;
                        
                        gameCtx.save();
                        gameCtx.translate(this.x, this.y);
                        gameCtx.rotate(spiralAngle);
                        
                        gameCtx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            const angle = (i / 5) * Math.PI * 2;
                            const outerRadius = this.radius;
                            const innerRadius = this.radius / 2;
                            
                            // 外点
                            gameCtx.lineTo(
                                Math.cos(angle) * outerRadius,
                                Math.sin(angle) * outerRadius
                            );
                            
                            // 内点
                            const innerAngle = angle + Math.PI / 5;
                            gameCtx.lineTo(
                                Math.cos(innerAngle) * innerRadius,
                                Math.sin(innerAngle) * innerRadius
                            );
                        }
                        gameCtx.closePath();
                        gameCtx.fill();
                        
                        gameCtx.restore();
                        break;
                        
                    case BULLET_TYPES.ENEMY_BOUNCE:
                        // 反弹弹
                        gameCtx.fillStyle = this.color;
                        
                        // 绘制六边形
                        gameCtx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (i / 6) * Math.PI * 2;
                            const x = this.x + Math.cos(angle) * this.radius;
                            const y = this.y + Math.sin(angle) * this.radius;
                            
                            if (i === 0) {
                                gameCtx.moveTo(x, y);
                            } else {
                                gameCtx.lineTo(x, y);
                            }
                        }
                        gameCtx.closePath();
                        gameCtx.fill();
                        
                        // 反弹次数指示
                        if (this.bounceCount > 0) {
                            gameCtx.fillStyle = "#ffffff";
                            gameCtx.font = "10px Arial";
                            gameCtx.textAlign = "center";
                            gameCtx.textBaseline = "middle";
                            gameCtx.fillText(this.bounceCount.toString(), this.x, this.y);
                        }
                        break;
                        
                    case BULLET_TYPES.ENEMY_HOMING:
                        // 追踪弹
                        gameCtx.fillStyle = this.color;
                        
                        // 平滑变化的脉动圆形
                        const homingPulse = 1 + 0.2 * Math.sin(this.lifetime * 0.2);
                        
                        gameCtx.beginPath();
                        gameCtx.arc(this.x, this.y, this.radius * homingPulse, 0, Math.PI * 2);
                        gameCtx.fill();
                        
                        // 追踪指示线
                        if (player) {
                            gameCtx.strokeStyle = this.color;
                            gameCtx.globalAlpha = 0.2;
                            gameCtx.setLineDash([3, 3]);
                            gameCtx.beginPath();
                            gameCtx.moveTo(this.x, this.y);
                            gameCtx.lineTo(player.x, player.y);
                            gameCtx.stroke();
                            gameCtx.setLineDash([]);
                        }
                        break;
                        
                    case BULLET_TYPES.ENEMY_ACCELERATING:
                        // 加速弹
                        const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                        const normalizedSpeed = Math.min(speed / (CONFIG.BULLET_SPEED * 2), 1);
                        
                        // 颜色从蓝到红根据速度变化
                        const r = Math.floor(255 * normalizedSpeed);
                        const b = Math.floor(255 * (1 - normalizedSpeed));
                        gameCtx.fillStyle = `rgb(${r}, 100, ${b})`;
                        
                        // 尾迹效果
                        gameCtx.globalAlpha = 0.3;
                        gameCtx.beginPath();
                        gameCtx.arc(
                            this.x - this.vx, 
                            this.y - this.vy, 
                            this.radius * 0.8, 
                            0, Math.PI * 2
                        );
                        gameCtx.fill();
                        
                        gameCtx.globalAlpha = 0.5;
                        gameCtx.beginPath();
                        gameCtx.arc(
                            this.x - this.vx * 0.5, 
                            this.y - this.vy * 0.5, 
                            this.radius * 0.9, 
                            0, Math.PI * 2
                        );
                        gameCtx.fill();
                        
                        // 主体
                        gameCtx.globalAlpha = 1;
                        gameCtx.beginPath();
                        gameCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        gameCtx.fill();
                        break;
                        
                    case BULLET_TYPES.ENEMY_DECELERATING:
                        // 减速弹
                        const slowSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                        const slowFactor = Math.max(slowSpeed / CONFIG.BULLET_SPEED, 0.2);
                        
                        // 多层次的半透明圆
                        for (let i = 3; i > 0; i--) {
                            gameCtx.fillStyle = this.color;
                            gameCtx.globalAlpha = 0.2 * i;
                            gameCtx.beginPath();
                            gameCtx.arc(
                                this.x, 
                                this.y, 
                                this.radius * (1 + (4 - i) * 0.3) * slowFactor, 
                                0, Math.PI * 2
                            );
                            gameCtx.fill();
                        }
                        
                        // 主体
                        gameCtx.globalAlpha = 1;
                        gameCtx.fillStyle = this.color;
                        gameCtx.beginPath();
                        gameCtx.arc(this.x, this.y, this.radius * slowFactor, 0, Math.PI * 2);
                        gameCtx.fill();
                        break;
                        
                    case BULLET_TYPES.ENEMY_CURVING:
                        // 曲线弹
                        gameCtx.fillStyle = this.color;
                        
                        // 绘制旋转椭圆
                        const curveAngle = Math.atan2(this.vy, this.vx);
                        
                        gameCtx.save();
                        gameCtx.translate(this.x, this.y);
                        gameCtx.rotate(curveAngle);
                        
                        gameCtx.beginPath();
                        gameCtx.ellipse(0, 0, this.radius * 1.5, this.radius * 0.8, 0, 0, Math.PI * 2);
                        gameCtx.fill();
                        
                        gameCtx.restore();
                        
                        // 绘制轨迹提示
                        gameCtx.strokeStyle = this.color;
                        gameCtx.globalAlpha = 0.2;
                        gameCtx.beginPath();
                        
                        // 预测轨迹
                        let predictX = this.x;
                        let predictY = this.y;
                        let predictAngle = this.angle;
                        let predictAngleSpeed = this.angleSpeed;
                        
                        for (let i = 1; i <= 10; i++) {
                            predictAngleSpeed += 0.001;
                            predictAngle += predictAngleSpeed;
                            
                            const predictVx = Math.cos(predictAngle) * CONFIG.BULLET_SPEED * 0.9;
                            const predictVy = Math.sin(predictAngle) * CONFIG.BULLET_SPEED * 0.9;
                            
                            predictX += predictVx;
                            predictY += predictVy;
                            
                            if (i === 1) {
                                gameCtx.moveTo(predictX, predictY);
                            } else {
                                gameCtx.lineTo(predictX, predictY);
                            }
                        }
                        
                        gameCtx.stroke();
                        break;
                        
                    case BULLET_TYPES.ENEMY_SPELL:
                        // 符卡特效子弹
                        
                        // 绘制特效粒子
                        this.spellEffects.forEach(effect => {
                            gameCtx.globalAlpha = effect.life / 20;
                            gameCtx.fillStyle = this.color;
                            gameCtx.beginPath();
                            gameCtx.arc(effect.x, effect.y, effect.size, 0, Math.PI * 2);
                            gameCtx.fill();
                        });
                        
                        // 绘制主体 - 闪烁变色的多边形
                        gameCtx.globalAlpha = 1;
                        const time = this.lifetime * 0.05;
                        const sides = 5 + Math.floor(time % 3);
                        
                        // 颜色随时间变化
                        const hue = (time * 20) % 360;
                        gameCtx.fillStyle = `hsl(${hue}, 100%, 70%)`;
                        
                        gameCtx.beginPath();
                        for (let i = 0; i < sides; i++) {
                            const angle = (i / sides) * Math.PI * 2 + time;
                            const x = this.x + Math.cos(angle) * this.radius;
                            const y = this.y + Math.sin(angle) * this.radius;
                            
                            if (i === 0) {
                                gameCtx.moveTo(x, y);
                            } else {
                                gameCtx.lineTo(x, y);
                            }
                        }
                        gameCtx.closePath();
                        gameCtx.fill();
                        
                        // 发光轮廓
                        gameCtx.strokeStyle = "#ffffff";
                        gameCtx.lineWidth = 2;
                        gameCtx.stroke();
                        break;
                }
                
                gameCtx.restore();
            }
        }
        
        // 敌人类
        class Enemy {
            constructor(x, y, type, pattern) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.pattern = pattern;
                this.width = 30;
                this.height = 30;
                this.speed = CONFIG.ENEMY_SPEED;
                this.shootCooldown = 0;
                this.health = 0;
                this.maxHealth = 0;
                this.animation = 0;
                this.bulletPattern = [];
                this.movementPattern = [];
                this.movementIndex = 0;
                this.shootPattern = [];
                this.shootIndex = 0;
                this.value = 0;
                this.isActive = true;
                this.deathAnimation = 0;
                
                // 根据敌人类型初始化
                this.initializeType();
            }
            
            initializeType() {
                switch(this.type) {
                    case ENEMY_TYPES.SMALL:
                        this.width = 20;
                        this.height = 20;
                        this.health = 10;
                        this.maxHealth = 10;
                        this.value = CONFIG.ENEMY_KILL_SCORE;
                        this.bulletPattern = [
                            BULLET_TYPES.ENEMY_SMALL
                        ];
                        break;
                        
                    case ENEMY_TYPES.MEDIUM:
                        this.width = 30;
                        this.height = 30;
                        this.health = 30;
                        this.maxHealth = 30;
                        this.value = CONFIG.ENEMY_KILL_SCORE * 2;
                        this.bulletPattern = [
                            BULLET_TYPES.ENEMY_NORMAL,
                            BULLET_TYPES.ENEMY_AIMED
                        ];
                        break;
                        
                    case ENEMY_TYPES.LARGE:
                        this.width = 40;
                        this.height = 40;
                        this.health = 80;
                        this.maxHealth = 80;
                        this.value = CONFIG.ENEMY_KILL_SCORE * 5;
                        this.bulletPattern = [
                            BULLET_TYPES.ENEMY_LARGE,
                            BULLET_TYPES.ENEMY_NORMAL,
                            BULLET_TYPES.ENEMY_SPIRAL
                        ];
                        break;
                        
                    case ENEMY_TYPES.MINIBOSS:
                        this.width = 60;
                        this.height = 60;
                        this.health = 300;
                        this.maxHealth = 300;
                        this.value = CONFIG.ENEMY_KILL_SCORE * 10;
                        this.bulletPattern = [
                            BULLET_TYPES.ENEMY_LARGE,
                            BULLET_TYPES.ENEMY_SPIRAL,
                            BULLET_TYPES.ENEMY_AIMED,
                            BULLET_TYPES.ENEMY_BOUNCE
                        ];
                        break;
                }
                
                // 根据关卡和难度调整敌人属性
                const rankMultiplier = 1 + (GAME_STATE.rank / 100);
                const stageMultiplier = 1 + (GAME_STATE.currentStage * 0.3);
                
                this.health *= rankMultiplier * stageMultiplier;
                this.maxHealth = this.health;
                this.value *= stageMultiplier;
                
                // 初始化移动模式
                this.initializeMovementPattern();
                
                // 初始化射击模式
                this.initializeShootPattern();
            }
            
            initializeMovementPattern() {
                const centerX = gameCanvas.width / 2;
                const centerY = gameCanvas.height / 2;
                
                switch(this.pattern) {
                    case "line":
                        // 直线移动
                        this.movementPattern = [
                            { x: this.x, y: gameCanvas.height + 50, speed: this.speed }
                        ];
                        break;
                        
                    case "v":
                        // V字形移动
                        this.movementPattern = [
                            { x: centerX, y: centerY, speed: this.speed * 0.8 },
                            { x: this.x < centerX ? 0 : gameCanvas.width, y: gameCanvas.height, speed: this.speed }
                        ];
                        break;
                        
                    case "circle":
                        // 圆形移动
                        const radius = 150;
                        const angle = Math.random() * Math.PI * 2;
                        const circleX = centerX + Math.cos(angle) * radius;
                        const circleY = centerY + Math.sin(angle) * radius;
                        
                        this.movementPattern = [
                            { x: circleX, y: circleY, speed: this.speed * 0.7 },
                            { x: circleX + Math.cos(angle + Math.PI / 2) * radius, 
                              y: circleY + Math.sin(angle + Math.PI / 2) * radius, 
                              speed: this.speed * 0.5 },
                            { x: circleX + Math.cos(angle + Math.PI) * radius, 
                              y: circleY + Math.sin(angle + Math.PI) * radius, 
                              speed: this.speed * 0.5 },
                            { x: circleX + Math.cos(angle + Math.PI * 3/2) * radius, 
                              y: circleY + Math.sin(angle + Math.PI * 3/2) * radius, 
                              speed: this.speed * 0.5 },
                            { x: circleX, y: circleY, speed: this.speed * 0.5 },
                            { x: circleX, y: gameCanvas.height + 100, speed: this.speed * 1.2 }
                        ];
                        break;
                        
                    case "random":
                        // 随机移动点
                        this.movementPattern = [];
                        let lastX = this.x;
                        let lastY = this.y;
                        
                        for (let i = 0; i < 5; i++) {
                            const x = CONFIG.BORDER_WIDTH + Math.random() * (gameCanvas.width - CONFIG.BORDER_WIDTH * 2);
                            const y = CONFIG.BORDER_WIDTH + Math.random() * (gameCanvas.height / 2);
                            
                            this.movementPattern.push({
                                x: x,
                                y: y,
                                speed: this.speed * (0.7 + Math.random() * 0.6)
                            });
                            
                            lastX = x;
                            lastY = y;
                        }
                        
                        // 最后离开屏幕
                        this.movementPattern.push({
                            x: lastX,
                            y: gameCanvas.height + 100,
                            speed: this.speed * 1.5
                        });
                        break;
                        
                    case "triangle":
                        // 三角形移动
                        const height = 200;
                        const width = 300;
                        const triangleX = centerX;
                        const triangleY = centerY - 100;
                        
                        this.movementPattern = [
                            { x: triangleX, y: triangleY, speed: this.speed * 0.8 },
                            { x: triangleX - width/2, y: triangleY + height, speed: this.speed * 0.6 },
                            { x: triangleX + width/2, y: triangleY + height, speed: this.speed * 0.6 },
                            { x: triangleX, y: triangleY, speed: this.speed * 0.6 },
                            { x: triangleX, y: gameCanvas.height + 100, speed: this.speed * 1.3 }
                        ];
                        break;
                        
                    case "wave":
                        // 波浪移动
                        this.movementPattern = [];
                        let waveX = this.x;
                        let waveY = this.y;
                        
                        for (let i = 0; i < 8; i++) {
                            waveX = (i % 2 === 0) ? 100 : gameCanvas.width - 100;
                            waveY += 80;
                            
                            this.movementPattern.push({
                                x: waveX,
                                y: waveY,
                                speed: this.speed * 0.9
                            });
                        }
                        
                        // 最后离开屏幕
                        this.movementPattern.push({
                            x: waveX,
                            y: gameCanvas.height + 100,
                            speed: this.speed * 1.4
                        });
                        break;
                        
                    case "cross":
                        // 十字移动
                        const crossX = this.x < centerX ? centerX - 150 : centerX + 150;
                        const crossY = centerY - 100;
                        
                        this.movementPattern = [
                            { x: crossX, y: crossY, speed: this.speed * 0.7 },
                            { x: centerX, y: centerY, speed: this.speed * 0.5 },
                            { x: gameCanvas.width - crossX, y: crossY, speed: this.speed * 0.5 },
                            { x: centerX, y: centerY + 100, speed: this.speed * 0.5 },
                            { x: crossX, y: crossY, speed: this.speed * 0.5 },
                            { x: this.x < centerX ? -50 : gameCanvas.width + 50, y: gameCanvas.height, speed: this.speed * 1.2 }
                        ];
                        break;
                        
                    case "spiral":
                        // 螺旋移动
                        this.movementPattern = [];
                        const spiralRadius = 150;
                        const spiralAngle = Math.random() * Math.PI * 2;
                        let currentAngle = spiralAngle;
                        
                        for (let i = 0; i < 12; i++) {
                            currentAngle += Math.PI / 6;
                            const radius = spiralRadius * (1 - i / 24);
                            
                            this.movementPattern.push({
                                x: centerX + Math.cos(currentAngle) * radius,
                                y: centerY + Math.sin(currentAngle) * radius,
                                speed: this.speed * 0.6
                            });
                        }
                        
                        // 最后离开屏幕
                        this.movementPattern.push({
                            x: this.x < centerX ? -50 : gameCanvas.width + 50,
                            y: gameCanvas.height + 100,
                            speed: this.speed * 1.3
                        });
                        break;
                        
                    case "diamond":
                        // 菱形移动
                        const diamondSize = 180;
                        
                        this.movementPattern = [
                            { x: centerX, y: centerY - diamondSize, speed: this.speed * 0.7 },
                            { x: centerX + diamondSize, y: centerY, speed: this.speed * 0.5 },
                            { x: centerX, y: centerY + diamondSize, speed: this.speed * 0.5 },
                            { x: centerX - diamondSize, y: centerY, speed: this.speed * 0.5 },
                            { x: centerX, y: centerY - diamondSize, speed: this.speed * 0.5 },
                            { x: this.x < centerX ? -50 : gameCanvas.width + 50, y: -50, speed: this.speed * 1.2 }
                        ];
                        break;
                        
                    case "center":
                        // 停在中心
                        this.movementPattern = [
                            { x: centerX, y: centerY, speed: this.speed * 0.8 },
                            { x: centerX, y: centerY, speed: 0, waitTime: 300 }, // 停留5秒
                            { x: this.x < centerX ? -50 : gameCanvas.width + 50, y: -50, speed: this.speed * 1.5 }
                        ];
                        break;
                        
                    case "formation":
                        // 编队移动 - 根据初始位置计算编队位置
                        const formationX = (this.x / gameCanvas.width) * (gameCanvas.width - 200) + 100;
                        const formationY = 200;
                        
                        this.movementPattern = [
                            { x: formationX, y: formationY, speed: this.speed * 0.7 },
                            { x: formationX, y: formationY, speed: 0, waitTime: 180 }, // 停留3秒
                            { x: formationX, y: gameCanvas.height + 100, speed: this.speed * 1.3 }
                        ];
                        break;
                        
                    case "square":
                        // 正方形移动
                        const squareSize = 200;
                        
                        this.movementPattern = [
                            { x: centerX - squareSize/2, y: centerY - squareSize/2, speed: this.speed * 0.7 },
                            { x: centerX + squareSize/2, y: centerY - squareSize/2, speed: this.speed * 0.5 },
                            { x: centerX + squareSize/2, y: centerY + squareSize/2, speed: this.speed * 0.5 },
                            { x: centerX - squareSize/2, y: centerY + squareSize/2, speed: this.speed * 0.5 },
                            { x: centerX - squareSize/2, y: centerY - squareSize/2, speed: this.speed * 0.5 },
                            { x: this.x < centerX ? -50 : gameCanvas.width + 50, y: this.y < centerY ? -50 : gameCanvas.height + 50, speed: this.speed * 1.4 }
                        ];
                        break;
                        
                    case "diagonal":
                        // 对角线移动
                        const startX = this.x < centerX ? 100 : gameCanvas.width - 100;
                        const startY = 100;
                        const endX = gameCanvas.width - startX;
                        const endY = gameCanvas.height - 100;
                        
                        this.movementPattern = [
                            { x: startX, y: startY, speed: this.speed * 0.8 },
                            { x: centerX, y: centerY, speed: this.speed * 0.5 },
                            { x: endX, y: endY, speed: this.speed * 0.7 },
                            { x: endX, y: endY, speed: 0, waitTime: 120 }, // 停留2秒
                            { x: endX, y: gameCanvas.height + 100, speed: this.speed * 1.5 }
                        ];
                        break;
                }
            }
            
            initializeShootPattern() {
                switch(this.type) {
                    case ENEMY_TYPES.SMALL:
                        // 简单射击模式
                        this.shootPattern = [
                            { cooldown: 60, bullets: [{ type: this.bulletPattern[0], count: 1, spread: 0 }] }
                        ];
                        break;
                        
                    case ENEMY_TYPES.MEDIUM:
                        // 中等射击模式
                        this.shootPattern = [
                            { cooldown: 45, bullets: [{ type: this.bulletPattern[0], count: 3, spread: 30 }] },
                            { cooldown: 90, bullets: [{ type: this.bulletPattern[1], count: 1, spread: 0 }] }
                        ];
                        break;
                        
                    case ENEMY_TYPES.LARGE:
                        // 复杂射击模式
                        this.shootPattern = [
                            { cooldown: 30, bullets: [{ type: this.bulletPattern[0], count: 1, spread: 0 }] },
                            { cooldown: 60, bullets: [{ type: this.bulletPattern[1], count: 5, spread: 60 }] },
                            { cooldown: 120, bullets: [{ type: this.bulletPattern[2], count: 8, spread: 360 }] }
                        ];
                        break;
                        
                    case ENEMY_TYPES.MINIBOSS:
                        // 小Boss射击模式
                        this.shootPattern = [
                            { cooldown: 30, bullets: [{ type: this.bulletPattern[0], count: 2, spread: 20 }] },
                            { cooldown: 45, bullets: [{ type: this.bulletPattern[1], count: 12, spread: 360 }] },
                            { cooldown: 75, bullets: [{ type: this.bulletPattern[2], count: 3, spread: 30 }] },
                            { cooldown: 120, bullets: [
                                { type: this.bulletPattern[0], count: 1, spread: 0 },
                                { type: this.bulletPattern[3], count: 6, spread: 360 }
                            ]}
                        ];
                        break;
                }
                
                // 根据难度调整射击频率
                const rankMultiplier = 1 + (GAME_STATE.rank / 200); // 0.5~1.5倍射击频率
                this.shootPattern.forEach(pattern => {
                    pattern.cooldown = Math.max(10, Math.floor(pattern.cooldown / rankMultiplier));
                });
            }
            
            update() {
                // 死亡动画
                if (this.health <= 0) {
                    this.deathAnimation++;
                    if (this.deathAnimation >= 30) {
                        // 死亡后掉落物品
                        this.dropItems();
                        
                        // 增加分数
                        GAME_STATE.score += this.value * GAME_STATE.pointValue;
                        
                        // 增加连击
                        GAME_STATE.combo++;
                        GAME_STATE.maxCombo = Math.max(GAME_STATE.combo, GAME_STATE.maxCombo);
                        
                        // 添加爆炸效果
                        effects.push(new Effect(this.x, this.y, EFFECT_TYPES.EXPLOSION, 60));
                        
                        return true; // 移除敌人
                    }
                    return false;
                }
                
                // 动画更新
                this.animation = (this.animation + 1) % 60;
                
                // 移动逻辑
                if (this.movementIndex < this.movementPattern.length) {
                    const target = this.movementPattern[this.movementIndex];
                    
                    // 检查是否需要等待
                    if (target.waitTime && target.waitTime > 0) {
                        target.waitTime--;
                        
                        // 等待时继续射击
                        this.handleShooting();
                    } else {
                        // 计算移动方向和距离
                        const dx = target.x - this.x;
                        const dy = target.y - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // 如果到达目标点，移动到下一个点
                        if (distance < target.speed) {
                            this.x = target.x;
                            this.y = target.y;
                            this.movementIndex++;
                        } else {
                            // 向目标移动
                            const angle = Math.atan2(dy, dx);
                            this.x += Math.cos(angle) * target.speed;
                            this.y += Math.sin(angle) * target.speed;
                            
                            // 移动时射击
                            this.handleShooting();
                        }
                    }
                } else {
                    // 移动完成，离开屏幕
                    return this.isOutOfBounds();
                }
                
                return false;
            }
            
            handleShooting() {
                if (this.shootCooldown <= 0) {
                    // 获取当前射击模式
                    const pattern = this.shootPattern[this.shootIndex];
                    
                    // 创建子弹
                    pattern.bullets.forEach(bulletGroup => {
                        this.shoot(bulletGroup.type, bulletGroup.count, bulletGroup.spread);
                    });
                    
                    // 更新冷却时间和射击索引
                    this.shootCooldown = pattern.cooldown;
                    this.shootIndex = (this.shootIndex + 1) % this.shootPattern.length;
                } else {
                    this.shootCooldown--;
                }
            }
            
            shoot(bulletType, bulletCount, spreadAngle) {
                for (let i = 0; i < bulletCount; i++) {
                    let angle;
                    
                    if (bulletCount === 1) {
                        // 单发子弹瞄准玩家
                        if (player) {
                            const dx = player.x - this.x;
                            const dy = player.y - this.y;
                            angle = Math.atan2(dy, dx);
                        } else {
                            angle = Math.PI / 2; // 默认向下
                        }
                    } else {
                        // 多发子弹扇形分布
                        const startAngle = -spreadAngle / 2 * (Math.PI / 180);
                        const angleStep = spreadAngle / (bulletCount - 1) * (Math.PI / 180);
                        angle = startAngle + i * angleStep;
                        
                        // 如果是360度发射，调整角度
                        if (spreadAngle === 360) {
                            angle = (i / bulletCount) * Math.PI * 2;
                        }
                    }
                    
                    // 确定子弹速度
                    let speed = CONFIG.BULLET_SPEED;
                    if (bulletType === BULLET_TYPES.ENEMY_LARGE) speed *= 0.8;
                    if (bulletType === BULLET_TYPES.ENEMY_SMALL) speed *= 1.2;
                    
                    // 根据子弹类型设置颜色
                    let color;
                    switch(bulletType) {
                        case BULLET_TYPES.ENEMY_NORMAL:
                            color = "#ff5555";
                            break;
                        case BULLET_TYPES.ENEMY_LARGE:
                            color = "#ff0000";
                            break;
                        case BULLET_TYPES.ENEMY_SMALL:
                            color = "#ff9999";
                            break;
                        case BULLET_TYPES.ENEMY_LASER:
                            color = "#ff2222";
                            break;
                        case BULLET_TYPES.ENEMY_AIMED:
                            color = "#ff6600";
                            break;
                        case BULLET_TYPES.ENEMY_SPIRAL:
                            color = "#ff00ff";
                            break;
                        case BULLET_TYPES.ENEMY_BOUNCE:
                            color = "#00ffff";
                            break;
                        case BULLET_TYPES.ENEMY_HOMING:
                            color = "#ffaa00";
                            break;
                        case BULLET_TYPES.ENEMY_ACCELERATING:
                            color = "#ff0088";
                            break;
                        case BULLET_TYPES.ENEMY_DECELERATING:
                            color = "#8800ff";
                            break;
                        case BULLET_TYPES.ENEMY_CURVING:
                            color = "#00ff88";
                            break;
                        default:
                            color = "#ffffff";
                    }
                    
                    // 创建子弹
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;
                    const radius = bulletType === BULLET_TYPES.ENEMY_LARGE ? CONFIG.ENEMY_BULLET_SIZE * 1.5 :
                                  bulletType === BULLET_TYPES.ENEMY_SMALL ? CONFIG.ENEMY_BULLET_SIZE * 0.7 :
                                  CONFIG.ENEMY_BULLET_SIZE;
                    
                    enemyBullets.push(new Bullet(
                        this.x, this.y,
                        vx, vy,
                        bulletType,
                        radius, 1, color
                    ));
                }
            }
            
            isOutOfBounds() {
                const margin = 100;
                return (
                    this.x < -margin ||
                    this.x > gameCanvas.width + margin ||
                    this.y < -margin ||
                    this.y > gameCanvas.height + margin
                );
            }
            
            dropItems() {
                // 根据敌人类型掉落不同的物品
                switch(this.type) {
                    case ENEMY_TYPES.SMALL:
                        // 小型敌人掉落少量点数和能量
                        if (Math.random() < 0.3) {
                            items.push(new Item(this.x, this.y, 0, 1, ITEM_TYPES.POWER));
                        }
                        if (Math.random() < 0.5) {
                            items.push(new Item(this.x, this.y, 0, 1, ITEM_TYPES.POINT));
                        }
                        break;
                        
                    case ENEMY_TYPES.MEDIUM:
                        // 中型敌人掉落更多物品
                        items.push(new Item(this.x, this.y, 0, 1, ITEM_TYPES.POWER));
                        for (let i = 0; i < 2; i++) {
                            items.push(new Item(
                                this.x + (Math.random() * 20 - 10),
                                this.y + (Math.random() * 20 - 10),
                                0, 1, ITEM_TYPES.POINT
                            ));
                        }
                        
                        // 小概率掉落特殊资源
                        if (Math.random() < 0.2) {
                            const resourceType = Math.floor(Math.random() * 3) + ITEM_TYPES.SPIRIT;
                            items.push(new Item(this.x, this.y, 0, 1, resourceType));
                        }
                        break;
                        
                    case ENEMY_TYPES.LARGE:
                        // 大型敌人掉落更多物品
                        for (let i = 0; i < 2; i++) {
                            items.push(new Item(
                                this.x + (Math.random() * 30 - 15),
                                this.y + (Math.random() * 30 - 15),
                                0, 1, ITEM_TYPES.POWER
                            ));
                        }
                        
                        for (let i = 0; i < 4; i++) {
                            items.push(new Item(
                                this.x + (Math.random() * 30 - 15),
                                this.y + (Math.random() * 30 - 15),
                                0, 1, ITEM_TYPES.POINT
                            ));
                        }
                        
                        // 中概率掉落特殊资源
                        if (Math.random() < 0.4) {
                            const resourceType = Math.floor(Math.random() * 3) + ITEM_TYPES.SPIRIT;
                            items.push(new Item(this.x, this.y, 0, 1, resourceType));
                        }
                        break;
                        
                    case ENEMY_TYPES.MINIBOSS:
                        // 小Boss掉落大量物品和特殊物品
                        for (let i = 0; i < 3; i++) {
                            items.push(new Item(
                                this.x + (Math.random() * 40 - 20),
                                this.y + (Math.random() * 40 - 20),
                                0, 1, ITEM_TYPES.POWER
                            ));
                        }
                        
                        for (let i = 0; i < 8; i++) {
                            items.push(new Item(
                                this.x + (Math.random() * 40 - 20),
                                this.y + (Math.random() * 40 - 20),
                                0, 1, ITEM_TYPES.POINT
                            ));
                        }
                        
                        // 必定掉落一个特殊资源
                        for (let i = 0; i < 3; i++) {
                            const resourceType = ITEM_TYPES.SPIRIT + i;
                            items.push(new Item(
                                this.x + (i * 20 - 20),
                                this.y,
                                0, 1, resourceType
                            ));
                        }
                        
                        // 小概率掉落炸弹或生命
                        if (Math.random() < 0.3) {
                            items.push(new Item(this.x, this.y, 0, 1, ITEM_TYPES.BOMB));
                        }
                        
                        if (Math.random() < 0.1) {
                            items.push(new Item(this.x, this.y, 0, 1, ITEM_TYPES.LIFE));
                        }
                        break;
                }
            }
            
            hit(damage) {
                // 敌人受伤
                this.health -= damage;
                
                // 添加命中效果
                effects.push(new Effect(this.x, this.y, EFFECT_TYPES.HIT, 10));
                
                // 如果击败敌人
                if (this.health <= 0) {
                    // 触发连击奖励
                    const comboBonus = Math.min(GAME_STATE.combo, 100) * 10;
                    GAME_STATE.score += comboBonus;
                    
                    // 添加连击效果
                    if (GAME_STATE.combo > 10) {
                        effects.push(new Effect(this.x, this.y, EFFECT_TYPES.BONUS, 30, `${GAME_STATE.combo}连击! +${comboBonus}`));
                    }
                }
                
                return this.health <= 0;
            }
            
            draw() {
                gameCtx.save();
                
                if (this.health <= 0) {
                    // 死亡动画
                    const explosionProgress = this.deathAnimation / 30;
                    
                    gameCtx.globalAlpha = 1 - explosionProgress;
                    
                    // 爆炸效果
                    gameCtx.fillStyle = "#ffffff";
                    gameCtx.beginPath();
                    gameCtx.arc(this.x, this.y, this.width * (1 + explosionProgress), 0, Math.PI * 2);
                    gameCtx.fill();
                    
                    gameCtx.globalAlpha = 0.7 - explosionProgress * 0.7;
                    gameCtx.fillStyle = "#ffaa00";
                    gameCtx.beginPath();
                    gameCtx.arc(this.x, this.y, this.width * (0.7 + explosionProgress * 1.5), 0, Math.PI * 2);
                    gameCtx.fill();
                } else {
                    // 根据敌人类型绘制不同外观
                    switch(this.type) {
                        case ENEMY_TYPES.SMALL:
                            // 小型敌人
                            gameCtx.fillStyle = "#ff5555";
                            gameCtx.beginPath();
                            gameCtx.arc(this.x, this.y, this.width/2, 0, Math.PI * 2);
                            gameCtx.fill();
                            
                            // 内部细节
                            gameCtx.fillStyle = "#ff9999";
                            gameCtx.beginPath();
                            gameCtx.arc(this.x, this.y, this.width/4, 0, Math.PI * 2);
                            gameCtx.fill();
                            break;
                            
                        case ENEMY_TYPES.MEDIUM:
                            // 中型敌人
                            gameCtx.fillStyle = "#ff8800";
                            
                            // 三角形主体
                            gameCtx.beginPath();
                            gameCtx.moveTo(this.x, this.y - this.height/2);
                            gameCtx.lineTo(this.x - this.width/2, this.y + this.height/2);
                            gameCtx.lineTo(this.x + this.width/2, this.y + this.height/2);
                            gameCtx.closePath();
                            gameCtx.fill();
                            
                            // 内部细节
                            gameCtx.fillStyle = "#ffcc00";
                            gameCtx.beginPath();
                            gameCtx.arc(this.x, this.y, this.width/4, 0, Math.PI * 2);
                            gameCtx.fill();
                            break;
                            
                        case ENEMY_TYPES.LARGE:
                            // 大型敌人
                            gameCtx.fillStyle = "#aa00ff";
                            
                            // 矩形主体
                            gameCtx.fillRect(
                                this.x - this.width/2,
                                this.y - this.height/2,
                                this.width,
                                this.height
                            );
                            
                            // 内部细节
                            gameCtx.fillStyle = "#dd88ff";
                            gameCtx.beginPath();
                            
                            // 十字形内部
                            gameCtx.fillRect(
                                this.x - this.width/10,
                                this.y - this.height/2 + 5,
                                this.width/5,
                                this.height - 10
                            );
                            
                            gameCtx.fillRect(
                                this.x - this.width/2 + 5,
                                this.y - this.height/10,
                                this.width - 10,
                                this.height/5
                            );
                            break;
                            
                        case ENEMY_TYPES.MINIBOSS:
                            // 小Boss
                            gameCtx.fillStyle = "#0088ff";
                            
                            // 六边形主体
                            gameCtx.beginPath();
                            for (let i = 0; i < 6; i++) {
                                const angle = (i / 6) * Math.PI * 2;
                                const x = this.x + Math.cos(angle) * this.width/2;
                                const y = this.y + Math.sin(angle) * this.height/2;
                                
                                if (i === 0) {
                                    gameCtx.moveTo(x, y);
                                } else {
                                    gameCtx.lineTo(x, y);
                                }
                            }
                            gameCtx.closePath();
                            gameCtx.fill();
                            
                            // 内部旋转细节
                            gameCtx.fillStyle = "#00ccff";
                            gameCtx.beginPath();
                            
                            const innerAngle = this.animation * 0.1;
                            for (let i = 0; i < 3; i++) {
                                const angle = innerAngle + (i / 3) * Math.PI * 2;
                                const x1 = this.x + Math.cos(angle) * this.width/4;
                                const y1 = this.y + Math.sin(angle) * this.height/4;
                                const x2 = this.x + Math.cos(angle + Math.PI/6) * this.width/8;
                                const y2 = this.y + Math.sin(angle + Math.PI/6) * this.height/8;
                                
                                gameCtx.moveTo(this.x, this.y);
                                gameCtx.lineTo(x1, y1);
                                gameCtx.lineTo(x2, y2);
                                gameCtx.closePath();
                            }
                            gameCtx.fill();
                            break;
                    }
                    
                    // 绘制生命条
                    const healthPercent = this.health / this.maxHealth;
                    const healthBarWidth = this.width;
                    const healthBarHeight = 4;
                    
                    gameCtx.fillStyle = "#333333";
                    gameCtx.fillRect(
                        this.x - healthBarWidth/2,
                        this.y + this.height/2 + 5,
                        healthBarWidth,
                        healthBarHeight
                    );
                    
                    gameCtx.fillStyle = healthPercent > 0.5 ? "#00ff00" : healthPercent > 0.25 ? "#ffff00" : "#ff0000";
                    gameCtx.fillRect(
                        this.x - healthBarWidth/2,
                        this.y + this.height/2 + 5,
                        healthBarWidth * healthPercent,
                        healthBarHeight
                    );
                }
                
                gameCtx.restore();
            }
        }
        
        // Boss类
        class Boss {
            constructor(bossData) {
                this.name = bossData.name;
                this.title = bossData.title;
                this.x = gameCanvas.width / 2;
                this.y = 100;
                this.width = 60;
                this.height = 60;
                this.speed = CONFIG.ENEMY_SPEED * 0.6;
                this.baseHealth = bossData.health * CONFIG.BOSS_HEALTH_MULTIPLIER;
                this.health = this.baseHealth;
                this.maxHealth = this.baseHealth;
                this.spellCards = bossData.spellCards;
                this.currentSpell = -1; // -1 表示非符卡阶段
                this.animation = 0;
                this.movementPattern = [];
                this.movementIndex = 0;
                this.shootCooldown = 0;
                this.spellTimer = 0;
                this.cardBonus = CONFIG.SPELLCARD_BONUS;
                this.captureBonus = CONFIG.CAPTURE_BONUS;
                this.invincible = false;
                this.phase = 0; // Boss战斗阶段
                this.phaseChange = false; // 标记阶段变化
                this.behaviorTime = 0; // 行为计时器
                this.behaviorState = "intro"; // intro, normal, spell, transition, defeated
                this.movementTime = 0; // 移动计时器
                this.movementTarget = { x: this.x, y: this.y }; // 当前移动目标
                this.movementSpeed = this.speed; // 当前移动速度
                this.shootPattern = []; // 当前射击模式
                this.introTime = 180; // 入场时间，3秒
                this.talkTime = 0; // 对话时间
                this.deathAnimation = 0; // 死亡动画
                this.portriatAlpha = 0; // 头像透明度
                this.appearEffect = 0; // 出场特效
                this.currentDialogue = null; // 当前对话
                this.specialAttacks = []; // 特殊攻击模式
                this.initializeMovementPattern();
                this.initializeSpellCards();
                this.initializeSpecialAttacks();
            }
            
            initializeMovementPattern() {
                // 初始化Boss移动模式
                const centerX = gameCanvas.width / 2;
                const maxX = gameCanvas.width - 100;
                const minX = 100;
                const maxY = 300;
                const minY = 100;
                
                // 创建基本移动模式
                this.movementPattern = [
                    // 左右移动
                    { x: minX, y: minY, speed: this.speed * 0.8, time: 180 },
                    { x: maxX, y: minY, speed: this.speed * 0.8, time: 180 },
                    
                    // 弧形移动
                    { x: centerX, y: maxY, speed: this.speed * 0.6, time: 120 },
                    { x: minX, y: minY, speed: this.speed * 0.6, time: 120 },
                    { x: centerX, y: maxY, speed: this.speed * 0.6, time: 120 },
                    { x: maxX, y: minY, speed: this.speed * 0.6, time: 120 },
                    
                    // 中心停留
                    { x: centerX, y: minY + 50, speed: this.speed, time: 240 }
                ];
            }
            
            initializeSpellCards() {
                // 初始化符卡并添加额外属性
                this.spellCards.forEach(spell => {
                    spell.active = false;
                    spell.completed = false;
                    spell.captured = false;
                    spell.bonus = this.cardBonus;
                    spell.remainingTime = spell.timeout * 60; // 转换为帧数
                    spell.originalHealth = spell.health * CONFIG.BOSS_HEALTH_MULTIPLIER;
                    spell.health = spell.originalHealth;
                    
                    // 初始化符卡历史记录
                    const spellId = `${this.name}_${spell.name}`;
                    if (!GAME_STATE.spellHistory[spellId]) {
                        GAME_STATE.spellHistory[spellId] = {
                            attempts: 0,
                            captures: 0,
                            lastAttempt: null
                        };
                    }
                });
            }
            
            initializeSpecialAttacks() {
                // 根据Boss初始化特殊攻击模式
                switch(this.name) {
                    case "露米娅":
                        this.specialAttacks = [
                            {
                                name: "暗夜迷雾",
                                cooldown: 600,
                                duration: 300,
                                action: () => {
                                    // 创建迷雾效果
                                    const fogEffect = {
                                        type: "fog",
                                        alpha: 0,
                                        maxAlpha: 0.7,
                                        duration: 300,
                                        current: 0
                                    };
                                    
                                    // 添加到舞台特效
                                    stageEffects.push(fogEffect);
                                    
                                    // 雾中生成额外的敌人
                                    for (let i = 0; i < 5; i++) {
                                        setTimeout(() => {
                                            const x = Math.random() * (gameCanvas.width - 200) + 100;
                                            enemies.push(new Enemy(x, -30, ENEMY_TYPES.SMALL, "random"));
                                        }, i * 500);
                                    }
                                }
                            },
                            {
                                name: "影子分身",
                                cooldown: 900,
                                duration: 200,
                                action: () => {
                                    // 创建Boss分身
                                    const shadowCount = 3;
                                    for (let i = 0; i < shadowCount; i++) {
                                        const shadow = {
                                            x: this.x,
                                            y: this.y,
                                            targetX: this.x + (Math.random() * 300 - 150),
                                            targetY: this.y + (Math.random() * 100 - 50),
                                            alpha: 0.7,
                                            lifetime: 200,
                                            width: this.width * 0.8,
                                            height: this.height * 0.8
                                        };
                                        
                                        bossShadows.push(shadow);
                                        
                                        // 分身也发射子弹
                                        setTimeout(() => {
                                            if (shadow.lifetime > 0) {
                                                for (let j = 0; j < 8; j++) {
                                                    const angle = (j / 8) * Math.PI * 2;
                                                    const speed = CONFIG.BULLET_SPEED * 0.7;
                                                    const vx = Math.cos(angle) * speed;
                                                    const vy = Math.sin(angle) * speed;
                                                    
                                                    enemyBullets.push(new Bullet(
                                                        shadow.x, shadow.y,
                                                        vx, vy,
                                                        BULLET_TYPES.ENEMY_SMALL,
                                                        CONFIG.ENEMY_BULLET_SIZE * 0.7, 1, "#aa55aa"
                                                    ));
                                                }
                                            }
                                        }, 1000);
                                    }
                                }
                            }
                        ];
                        break;
                        
                    case "琪露诺":
                        this.specialAttacks = [
                            {
                                name: "冰冻领域",
                                cooldown: 720,
                                duration: 360,
                                action: () => {
                                    // 创建冰冻效果
                                    const iceEffect = {
                                        type: "ice",
                                        alpha: 0,
                                        maxAlpha: 0.5,
                                        duration: 360,
                                        current: 0,
                                        slowFactor: 0.7 // 减速30%
                                    };
                                    
                                    stageEffects.push(iceEffect);
                                    
                                    // 在随机位置创建冰块障碍
                                    for (let i = 0; i < 6; i++) {
                                        const ice = {
                                            x: 100 + Math.random() * (gameCanvas.width - 200),
                                            y: 100 + Math.random() * (gameCanvas.height - 300),
                                            width: 30 + Math.random() * 20,
                                            height: 30 + Math.random() * 20,
                                            lifetime: 360,
                                            alpha: 0,
                                            rotation: Math.random() * Math.PI * 2
                                        };
                                        
                                        stageObstacles.push(ice);
                                    }
                                }
                            },
                            {
                                name: "冰晶风暴",
                                cooldown: 900,
                                duration: 240,
                                action: () => {
                                    // 创建螺旋冰弹
                                    const spiralCount = 8;
                                    const burstCount = 5;
                                    
                                    for (let burst = 0; burst < burstCount; burst++) {
                                        setTimeout(() => {
                                            for (let i = 0; i < spiralCount; i++) {
                                                const angle = (i / spiralCount) * Math.PI * 2 + (burst / burstCount) * Math.PI;
                                                const speed = CONFIG.BULLET_SPEED * 0.8;
                                                const vx = Math.cos(angle) * speed;
                                                const vy = Math.sin(angle) * speed;
                                                
                                                enemyBullets.push(new Bullet(
                                                    this.x, this.y,
                                                    vx, vy,
                                                    BULLET_TYPES.ENEMY_BOUNCE,
                                                    CONFIG.ENEMY_BULLET_SIZE, 1, "#00ccff"
                                                ));
                                            }
                                        }, burst * 500);
                                    }
                                    
                                    // 创建减速区域
                                    for (let i = 0; i < 3; i++) {
                                        setTimeout(() => {
                                            const slowArea = {
                                                x: 100 + Math.random() * (gameCanvas.width - 200),
                                                y: 200 + Math.random() * (gameCanvas.height - 400),
                                                radius: 80,
                                                slowFactor: 0.5,
                                                lifetime: 180,
                                                alpha: 0
                                            };
                                            
                                            stageHazards.push(slowArea);
                                        }, i * 1000);
                                    }
                                }
                            }
                        ];
                        break;
                        
                    case "蕾米莉亚":
                        this.specialAttacks = [
                            {
                                name: "红雾领域",
                                cooldown: 600,
                                duration: 400,
                                action: () => {
                                    // 创建红雾效果
                                    const mistEffect = {
                                        type: "redMist",
                                        alpha: 0,
                                        maxAlpha: 0.6,
                                        duration: 400,
                                        current: 0
                                    };
                                    
                                    stageEffects.push(mistEffect);
                                    
                                    // 在雾中随机生成蝙蝠
                                    for (let i = 0; i < 12; i++) {
                                        setTimeout(() => {
                                            const bat = {
                                                x: Math.random() * gameCanvas.width,
                                                y: -20,
                                                speedX: Math.random() * 4 - 2,
                                                speedY: 2 + Math.random() * 2,
                                                size: 10 + Math.random() * 5,
                                                lifetime: 300,
                                                canShoot: Math.random() < 0.3,
                                                nextShoot: 60 + Math.random() * 60
                                            };
                                            
                                            stageBats.push(bat);
                                        }, i * 400);
                                    }
                                }
                            },
                            {
                                name: "命运操控",
                                cooldown: 800,
                                duration: 300,
                                action: () => {
                                    // 创建命运圈效果
                                    const circleCount = 3;
                                    for (let i = 0; i < circleCount; i++) {
                                        const fateCircle = {
                                            centerX: gameCanvas.width / 2,
                                            centerY: gameCanvas.height / 2,
                                            radius: 100 + i * 60,
                                            rotationSpeed: (i % 2 === 0 ? 1 : -1) * (0.01 + i * 0.005),
                                            currentAngle: i * (Math.PI / circleCount),
                                            bulletCount: 8 + i * 4,
                                            lifetime: 300,
                                            nextShoot: 30 + i * 10,
                                            shootInterval: 30 - i * 5
                                        };
                                        
                                        stageFateCircles.push(fateCircle);
                                    }
                                    
                                    // Boss移动到中心
                                    this.movementTarget = {
                                        x: gameCanvas.width / 2,
                                        y: 150
                                    };
                                    this.movementSpeed = this.speed * 2;
                                }
                            }
                        ];
                        break;
                }
            }
            
            update() {
                // 更新动画
                this.animation = (this.animation + 1) % 60;
                
                // 处理入场动画
                if (this.behaviorState === "intro") {
                    this.introTime--;
                    this.appearEffect++;
                    
                    if (this.introTime <= 0) {
                        // 入场完成，开始对话
                        this.behaviorState = "talking";
                        this.talkTime = 180; // 3秒对话时间
                        this.portriatAlpha = 1;
                        this.currentDialogue = {
                            portrait: this.name,
                            text: `我是${this.name}，${this.title}！准备好迎接挑战了吗？`,
                            time: 180
                        };
                    }
                    
                    return false;
                }
                
                // 处理对话
                if (this.behaviorState === "talking") {
                    this.talkTime--;
                    
                    if (this.talkTime <= 0) {
                        // 对话结束，开始战斗
                        this.behaviorState = "normal";
                        this.portriatAlpha = 0;
                        this.currentDialogue = null;
                    }
                    
                    return false;
                }
                
                // 死亡检测
                if (this.health <= 0) {
                    if (this.behaviorState !== "defeated") {
                        this.behaviorState = "defeated";
                        this.deathAnimation = 0;
                        
                        // 如果在符卡中被击败，检查是否完美击破
                        if (this.currentSpell >= 0) {
                            const spell = this.spellCards[this.currentSpell];
                            spell.active = false;
                            spell.completed = true;
                            
                            // 记录符卡历史
                            const spellId = `${this.name}_${spell.name}`;
                            GAME_STATE.spellHistory[spellId].attempts++;
                            GAME_STATE.spellHistory[spellId].lastAttempt = new Date().toISOString();
                            
                            // 如果时间还有剩余，视为符卡收集
                            if (spell.remainingTime > 0) {
                                spell.captured = true;
                                GAME_STATE.score += spell.bonus + this.captureBonus;
                                
                                // 添加符卡捕获效果
                                effects.push(new Effect(this.x, this.y, EFFECT_TYPES.SPELL_END, 60, 
                                                      `${spell.name} 完美击破! +${spell.bonus + this.captureBonus}`));
                                
                                GAME_STATE.spellHistory[spellId].captures++;
                                
                                // 检查符卡收集者成就
                                checkAchievement("spell_collector", 1);
                                
                                // 检查完美击破成就
                                checkAchievement("perfect_spell", 1);
                            } else {
                                // 超时但击破
                                GAME_STATE.score += spell.bonus / 2;
                                effects.push(new Effect(this.x, this.y, EFFECT_TYPES.SPELL_END, 60, 
                                                      `${spell.name} 击破! +${spell.bonus / 2}`));
                            }
                        }
                        
                        // 对话
                        this.portriatAlpha = 1;
                        this.talkTime = 180; // 3秒
                        this.currentDialogue = {
                            portrait: this.name,
                            text: "不可能...我竟然输了...",
                            time: 180
                        };
                    }
                    
                    // 更新死亡动画
                    this.deathAnimation++;
                    this.talkTime--;
                    
                    if (this.talkTime <= 0) {
                        this.portriatAlpha = Math.max(0, this.portriatAlpha - 0.05);
                    }
                    
                    if (this.deathAnimation >= 180) { // 3秒死亡动画
                        // 丢弃奖励物品
                        this.dropItems();
                        
                        // 显示阶段完成
                        showStageClear();
                        
                        // 清除所有子弹
                        enemyBullets = [];
                        
                        return true; // 移除Boss
                    }
                    
                    return false;
                }
                
                // 阶段切换检测
                if (!this.phaseChange && this.health <= this.maxHealth * (1 - (this.phase + 1) / this.spellCards.length)) {
                    this.phaseChange = true;
                    this.phase++;
                    
                    // 开始过渡到下一阶段
                    this.behaviorState = "transition";
                    this.behaviorTime = 90; // 1.5秒过渡
                    this.invincible = true;
                    
                    // 清除屏幕上的子弹
                    enemyBullets = [];
                    
                    // 移动到中心位置
                    this.movementTarget = {
                        x: gameCanvas.width / 2,
                        y: 150
                    };
                    this.movementSpeed = this.speed * 2;
                }
                
                // 处理状态
                switch(this.behaviorState) {
                    case "normal":
                        // 普通阶段行为
                        this.updateMovement();
                        this.updateNormalAttack();
                        break;
                        
                    case "spell":
                        // 符卡阶段行为
                        this.updateMovement();
                        this.updateSpellcard();
                        break;
                        
                    case "transition":
                        // 过渡阶段行为
                        this.behaviorTime--;
                        
                        // 移动到目标位置
                        const dx = this.movementTarget.x - this.x;
                        const dy = this.movementTarget.y - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > this.movementSpeed) {
                            const angle = Math.atan2(dy, dx);
                            this.x += Math.cos(angle) * this.movementSpeed;
                            this.y += Math.sin(angle) * this.movementSpeed;
                        } else {
                            this.x = this.movementTarget.x;
                            this.y = this.movementTarget.y;
                        }
                        
                        // 过渡结束后开始符卡
                        if (this.behaviorTime <= 0) {
                            this.startSpellcard(this.phase - 1);
                            this.phaseChange = false;
                            this.invincible = false;
                        }
                        break;
                }
                
                return false;
            }
            
            updateMovement() {
                // 更新移动
                if (this.movementTime <= 0) {
                    // 选择新的移动目标
                    const pattern = this.movementPattern[this.movementIndex];
                    
                    this.movementTarget = {
                        x: pattern.x,
                        y: pattern.y
                    };
                    
                    this.movementSpeed = pattern.speed;
                    this.movementTime = pattern.time;
                    
                    this.movementIndex = (this.movementIndex + 1) % this.movementPattern.length;
                }
                
                // 移动到目标位置
                const dx = this.movementTarget.x - this.x;
                const dy = this.movementTarget.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > this.movementSpeed) {
                    const angle = Math.atan2(dy, dx);
                    this.x += Math.cos(angle) * this.movementSpeed;
                    this.y += Math.sin(angle) * this.movementSpeed;
                } else {
                    this.x = this.movementTarget.x;
                    this.y = this.movementTarget.y;
                }
                
                this.movementTime--;
            }
            
            updateNormalAttack() {
                // 普通阶段的攻击模式
                if (this.shootCooldown <= 0) {
                    // 根据Boss特性选择攻击模式
                    const attackPatterns = [
                        // 圆形弹幕
                        () => {
                            const bulletCount = 16 + Math.floor(GAME_STATE.rank / 20);
                            
                            for (let i = 0; i < bulletCount; i++) {
                                const angle = (i / bulletCount) * Math.PI * 2;
                                const speed = CONFIG.BULLET_SPEED * 0.8;
                                const vx = Math.cos(angle) * speed;
                                const vy = Math.sin(angle) * speed;
                                
                                enemyBullets.push(new Bullet(
                                    this.x, this.y,
                                    vx, vy,
                                    BULLET_TYPES.ENEMY_NORMAL,
                                    CONFIG.ENEMY_BULLET_SIZE, 1, "#ff0000"
                                ));
                            }
                            
                            this.shootCooldown = 60;
                        },
                        
                        // 瞄准玩家的多重弹幕
                        () => {
                            if (player) {
                                const dx = player.x - this.x;
                                const dy = player.y - this.y;
                                const angle = Math.atan2(dy, dx);
                                
                                // 中心弹
                                const speed = CONFIG.BULLET_SPEED * 0.9;
                                enemyBullets.push(new Bullet(
                                    this.x, this.y,
                                    Math.cos(angle) * speed,
                                    Math.sin(angle) * speed,
                                    BULLET_TYPES.ENEMY_AIMED,
                                    CONFIG.ENEMY_BULLET_SIZE, 1, "#ff6600"
                                ));
                                
                                // 侧面弹
                                const spreadCount = 4;
                                const spreadAngle = Math.PI / 6;
                                
                                for (let i = 1; i <= spreadCount; i++) {
                                    const angleLeft = angle - (i * spreadAngle / spreadCount);
                                    const angleRight = angle + (i * spreadAngle / spreadCount);
                                    
                                    enemyBullets.push(new Bullet(
                                        this.x, this.y,
                                        Math.cos(angleLeft) * speed * 0.8,
                                        Math.sin(angleLeft) * speed * 0.8,
                                        BULLET_TYPES.ENEMY_SMALL,
                                        CONFIG.ENEMY_BULLET_SIZE * 0.7, 1, "#ff9900"
                                    ));
                                    
                                    enemyBullets.push(new Bullet(
                                        this.x, this.y,
                                        Math.cos(angleRight) * speed * 0.8,
                                        Math.sin(angleRight) * speed * 0.8,
                                        BULLET_TYPES.ENEMY_SMALL,
                                        CONFIG.ENEMY_BULLET_SIZE * 0.7, 1, "#ff9900"
                                    ));
                                }
                            }
                            
                            this.shootCooldown = 45;
                        },
                        
                        // 同心圆弹幕
                        () => {
                            const rings = 3;
                            const bulletPerRing = 12;
                            
                            for (let ring = 0; ring < rings; ring++) {
                                const speed = CONFIG.BULLET_SPEED * (0.7 + ring * 0.15);
                                const offset = (ring / rings) * (Math.PI / bulletPerRing);
                                
                                for (let i = 0; i < bulletPerRing; i++) {
                                    const angle = offset + (i / bulletPerRing) * Math.PI * 2;
                                    const vx = Math.cos(angle) * speed;
                                    const vy = Math.sin(angle) * speed;
                                    
                                    enemyBullets.push(new Bullet(
                                        this.x, this.y,
                                        vx, vy,
                                        BULLET_TYPES.ENEMY_NORMAL,
                                        CONFIG.ENEMY_BULLET_SIZE, 1, "#ff0088"
                                    ));
                                }
                            }
                            
                            this.shootCooldown = 90;
                        }
                    ];
                    
                    // 随机选择一种攻击模式
                    const attackIndex = Math.floor(Math.random() * attackPatterns.length);
                    attackPatterns[attackIndex]();
                    
                    // 尝试使用特殊攻击
                    this.trySpecialAttack();
                } else {
                    this.shootCooldown--;
                }
            }
            
            trySpecialAttack() {
                // 检查是否有可用的特殊攻击
                if (this.specialAttacks.length > 0) {
                    // 找到冷却完成的特殊攻击
                    for (let i = 0; i < this.specialAttacks.length; i++) {
                        const attack = this.specialAttacks[i];
                        
                        if (!attack.cooldownRemaining || attack.cooldownRemaining <= 0) {
                            // 触发特殊攻击
                            attack.action();
                            
                            // 设置冷却
                            attack.cooldownRemaining = attack.cooldown;
                            
                            // 添加特效
                            effects.push(new Effect(this.x, this.y, EFFECT_TYPES.SPELL_START, 60, attack.name));
                            
                            break;
                        }
                    }
                }
                
                // 更新特殊攻击冷却
                this.specialAttacks.forEach(attack => {
                    if (attack.cooldownRemaining) {
                        attack.cooldownRemaining--;
                    }
                });
            }
            
            startSpellcard(index) {
                if (index >= 0 && index < this.spellCards.length) {
                    // 激活符卡
                    this.currentSpell = index;
                    const spell = this.spellCards[index];
                    
                    spell.active = true;
                    spell.completed = false;
                    spell.captured = false;
                    spell.health = spell.originalHealth;
                    spell.remainingTime = spell.timeout * 60;
                    
                    // 更新状态
                    this.behaviorState = "spell";
                    this.invincible = false;
                    
                    // 清除屏幕上的子弹
                    enemyBullets = [];
                    
                    // 显示符卡宣言
                    announceSpellcard(spell.name);
                    
                    // 记录符卡历史
                    const spellId = `${this.name}_${spell.name}`;
                    if (!GAME_STATE.spellHistory[spellId]) {
                        GAME_STATE.spellHistory[spellId] = {
                            attempts: 0,
                            captures: 0,
                            lastAttempt: null
                        };
                    }
                }
            }
            
            updateSpellcard() {
                if (this.currentSpell >= 0 && this.currentSpell < this.spellCards.length) {
                    const spell = this.spellCards[this.currentSpell];
                    
                    // 更新符卡时间
                    if (spell.active) {
                        spell.remainingTime--;
                        
                        // 检查符卡是否超时
                        if (spell.remainingTime <= 0) {
                            spell.active = false;
                            spell.completed = true;
                            
                            // 记录符卡历史
                            const spellId = `${this.name}_${spell.name}`;
                            GAME_STATE.spellHistory[spellId].attempts++;
                            GAME_STATE.spellHistory[spellId].lastAttempt = new Date().toISOString();
                            
                            // 超时惩罚
                            this.health = 0; // 直接进入下一阶段
                            
                            return;
                        }
                        
                        // 处理符卡攻击
                        if (this.shootCooldown <= 0) {
                            // 根据符卡类型选择攻击模式
                            this.executeSpellcardAttack(spell);
                            
                            // 重置射击冷却
                            this.shootCooldown = 30;
                        } else {
                            this.shootCooldown--;
                        }
                    }
                }
            }
            
            executeSpellcardAttack(spell) {
                // 根据符卡的子弹类型执行攻击
                const attackPatterns = {
                    // 螺旋弹幕
                    [BULLET_TYPES.ENEMY_SPIRAL]: () => {
                        const spiralCount = 2 + Math.floor(GAME_STATE.rank / 30);
                        const bulletPerSpiral = 24;
                        const baseAngle = this.animation * 0.05;
                        
                        for (let spiral = 0; spiral < spiralCount; spiral++) {
                            const spiralOffset = (spiral / spiralCount) * Math.PI * 2;
                            
                            for (let i = 0; i < bulletPerSpiral; i++) {
                                const distance = 20 + i * 10;
                                const angle = baseAngle + spiralOffset + (i * 0.1);
                                const x = this.x + Math.cos(angle) * distance;
                                const y = this.y + Math.sin(angle) * distance;
                                
                                const speed = CONFIG.BULLET_SPEED * 0.7;
                                const vx = Math.cos(angle) * speed;
                                const vy = Math.sin(angle) * speed;
                                
                                enemyBullets.push(new Bullet(
                                    x, y,
                                    vx, vy,
                                    BULLET_TYPES.ENEMY_SPIRAL,
                                    CONFIG.ENEMY_BULLET_SIZE * 0.8, 1, "#ff00ff"
                                ));
                            }
                        }
                    },
                    
                    // 小型弹幕
                    [BULLET_TYPES.ENEMY_SMALL]: () => {
                        const density = 20 + Math.floor(GAME_STATE.rank / 10);
                        
                        for (let i = 0; i < density; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = 20 + Math.random() * 30;
                            const x = this.x + Math.cos(angle) * distance;
                            const y = this.y + Math.sin(angle) * distance;
                            
                            const speed = CONFIG.BULLET_SPEED * (0.6 + Math.random() * 0.6);
                            const vx = Math.cos(angle) * speed;
                            const vy = Math.sin(angle) * speed;
                            
                            enemyBullets.push(new Bullet(
                                x, y,
                                vx, vy,
                                BULLET_TYPES.ENEMY_SMALL,
                                CONFIG.ENEMY_BULLET_SIZE * 0.7, 1, "#ff9999"
                            ));
                        }
                    },
                    
                    // 大型弹幕
                    [BULLET_TYPES.ENEMY_LARGE]: () => {
                        const ringCount = 3;
                        const baseSpeed = CONFIG.BULLET_SPEED * 0.6;
                        
                        for (let ring = 0; ring < ringCount; ring++) {
                            const bulletCount = 6 + ring * 2;
                            const speed = baseSpeed + ring * 0.2;
                            
                            for (let i = 0; i < bulletCount; i++) {
                                const angle = (i / bulletCount) * Math.PI * 2;
                                const vx = Math.cos(angle) * speed;
                                const vy = Math.sin(angle) * speed;
                                
                                enemyBullets.push(new Bullet(
                                    this.x, this.y,
                                    vx, vy,
                                    BULLET_TYPES.ENEMY_LARGE,
                                    CONFIG.ENEMY_BULLET_SIZE * 1.3, 1, "#ff0000"
                                ));
                            }
                        }
                    },
                    
                    // 瞄准型弹幕
                    [BULLET_TYPES.ENEMY_AIMED]: () => {
                        if (player) {
                            const dx = player.x - this.x;
                            const dy = player.y - this.y;
                            const angle = Math.atan2(dy, dx);
                            
                            // 多重瞄准
                            const groups = 3 + Math.floor(GAME_STATE.rank / 25);
                            
                            for (let group = 0; group < groups; group++) {
                                const delay = group * 10;
                                
                                setTimeout(() => {
                                    if (player) {
                                        const newDx = player.x - this.x;
                                        const newDy = player.y - this.y;
                                        const newAngle = Math.atan2(newDy, newDx);
                                        
                                        const speed = CONFIG.BULLET_SPEED * 0.8;
                                        const spreadCount = 5;
                                        const spreadAngle = Math.PI / 12;
                                        
                                        for (let i = -spreadCount; i <= spreadCount; i++) {
                                            const bulletAngle = newAngle + i * (spreadAngle / spreadCount);
                                            const vx = Math.cos(bulletAngle) * speed;
                                            const vy = Math.sin(bulletAngle) * speed;
                                            
                                            enemyBullets.push(new Bullet(
                                                this.x, this.y,
                                                vx, vy,
                                                BULLET_TYPES.ENEMY_AIMED,
                                                CONFIG.ENEMY_BULLET_SIZE, 1, "#ff6600"
                                            ));
                                        }
                                    }
                                }, delay);
                            }
                        }
                    },
                    
                    // 反弹弹幕
                    [BULLET_TYPES.ENEMY_BOUNCE]: () => {
                        const baseAngle = this.animation * 0.05;
                        const bulletGroups = 4;
                        const bulletsPerGroup = 6;
                        
                        for (let group = 0; group < bulletGroups; group++) {
                            const groupAngle = baseAngle + (group / bulletGroups) * Math.PI * 2;
                            
                            for (let i = 0; i < bulletsPerGroup; i++) {
                                const angle = groupAngle + (i / bulletsPerGroup) * Math.PI * 0.25;
                        const speed = CONFIG.BULLET_SPEED * 0.9;
                        const vx = Math.cos(angle) * speed;
                        const vy = Math.sin(angle) * speed;
                        
                        enemyBullets.push(new Bullet(
                            this.x, this.y,
                            vx, vy,
                            BULLET_TYPES.ENEMY_BOUNCE,
                            CONFIG.ENEMY_BULLET_SIZE, 1, "#00ffff"
                        ));
                    }
                }
            },
            
            // 曲线弹幕
            [BULLET_TYPES.ENEMY_CURVING]: () => {
                const baseAngle = this.animation * 0.02;
                const bulletCount = 24;
                
                for (let i = 0; i < bulletCount; i++) {
                    const angle = baseAngle + (i / bulletCount) * Math.PI * 2;
                    const speed = CONFIG.BULLET_SPEED * 0.75;
                    
                    // 创建两个相反曲率的子弹
                    const bullet1 = new Bullet(
                        this.x, this.y,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        BULLET_TYPES.ENEMY_CURVING,
                        CONFIG.ENEMY_BULLET_SIZE, 1, "#00ff88"
                    );
                    bullet1.angleSpeed = 0.01;
                    enemyBullets.push(bullet1);
                    
                    const bullet2 = new Bullet(
                        this.x, this.y,
                        Math.cos(angle + Math.PI) * speed,
                        Math.sin(angle + Math.PI) * speed,
                        BULLET_TYPES.ENEMY_CURVING,
                        CONFIG.ENEMY_BULLET_SIZE, 1, "#88ff00"
                    );
                    bullet2.angleSpeed = -0.01;
                    enemyBullets.push(bullet2);
                }
            },
            
            // 追踪弹幕
            [BULLET_TYPES.ENEMY_HOMING]: () => {
                const bulletCount = 8 + Math.floor(GAME_STATE.rank / 20);
                
                for (let i = 0; i < bulletCount; i++) {
                    const angle = (i / bulletCount) * Math.PI * 2;
                    const speed = CONFIG.BULLET_SPEED * 0.6;
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;
                    
                    enemyBullets.push(new Bullet(
                        this.x, this.y,
                        vx, vy,
                        BULLET_TYPES.ENEMY_HOMING,
                        CONFIG.ENEMY_BULLET_SIZE, 1, "#ffaa00"
                    ));
                }
            },
            
            // 加速弹幕
            [BULLET_TYPES.ENEMY_ACCELERATING]: () => {
                const ringCount = 3;
                const baseSpeed = CONFIG.BULLET_SPEED * 0.5;
                
                for (let ring = 0; ring < ringCount; ring++) {
                    const bulletCount = 12;
                    const delay = ring * 15;
                    
                    setTimeout(() => {
                        for (let i = 0; i < bulletCount; i++) {
                            const angle = (i / bulletCount) * Math.PI * 2;
                            const vx = Math.cos(angle) * baseSpeed;
                            const vy = Math.sin(angle) * baseSpeed;
                            
                            enemyBullets.push(new Bullet(
                                this.x, this.y,
                                vx, vy,
                                BULLET_TYPES.ENEMY_ACCELERATING,
                                CONFIG.ENEMY_BULLET_SIZE, 1, "#ff0088"
                            ));
                        }
                    }, delay);
                }
            },
            
            // 减速弹幕
            [BULLET_TYPES.ENEMY_DECELERATING]: () => {
                const density = 16 + Math.floor(GAME_STATE.rank / 15);
                const speed = CONFIG.BULLET_SPEED * 1.2;
                
                for (let i = 0; i < density; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;
                    
                    enemyBullets.push(new Bullet(
                        this.x, this.y,
                        vx, vy,
                        BULLET_TYPES.ENEMY_DECELERATING,
                        CONFIG.ENEMY_BULLET_SIZE * 0.9, 1, "#8800ff"
                    ));
                }
            },
            
            // 激光弹幕
            [BULLET_TYPES.ENEMY_LASER]: () => {
                const laserCount = 4 + Math.floor(GAME_STATE.rank / 25);
                const baseAngle = this.animation * 0.01;
                
                for (let i = 0; i < laserCount; i++) {
                    const angle = baseAngle + (i / laserCount) * Math.PI * 2;
                    const vx = Math.cos(angle) * 0.1; // 激光移动很慢
                    const vy = Math.sin(angle) * 0.1;
                    
                    enemyBullets.push(new Bullet(
                        this.x, this.y,
                        vx, vy,
                        BULLET_TYPES.ENEMY_LASER,
                        CONFIG.ENEMY_BULLET_SIZE * 5, 1, "#ff2222"
                    ));
                }
            },
            
            // 符卡特效弹幕
            [BULLET_TYPES.ENEMY_SPELL]: () => {
                // 复杂的符卡特效攻击
                const baseAngle = this.animation * 0.03;
                const waveCount = 5;
                
                for (let wave = 0; wave < waveCount; wave++) {
                    const delay = wave * 12;
                    
                    setTimeout(() => {
                        const bulletCount = 24;
                        
                        for (let i = 0; i < bulletCount; i++) {
                            const angle = baseAngle + (i / bulletCount) * Math.PI * 2;
                            const speed = CONFIG.BULLET_SPEED * (0.7 + Math.sin(wave * 0.5) * 0.3);
                            const vx = Math.cos(angle) * speed;
                            const vy = Math.sin(angle) * speed;
                            
                            // 不同波次不同颜色
                            const hue = (wave * 50) % 360;
                            const color = `hsl(${hue}, 100%, 60%)`;
                            
                            enemyBullets.push(new Bullet(
                                this.x, this.y,
                                vx, vy,
                                BULLET_TYPES.ENEMY_SPELL,
                                CONFIG.ENEMY_BULLET_SIZE * 1.1, 1, color
                            ));
                        }
                    }, delay);
                }
            }
        };
        
        // 执行符卡定义的所有攻击
        spell.bullets.forEach(bulletType => {
            if (attackPatterns[bulletType]) {
                attackPatterns[bulletType]();
            }
        });
    }
    
    dropItems() {
        // Boss掉落大量物品
        
        // 掉落能量
        for (let i = 0; i < 10; i++) {
            items.push(new Item(
                this.x + (Math.random() * 100 - 50),
                this.y + (Math.random() * 100 - 50),
                Math.random() * 4 - 2,
                Math.random() * 2 + 1,
                ITEM_TYPES.POWER
            ));
        }
        
        // 掉落点数
        for (let i = 0; i < 20; i++) {
            items.push(new Item(
                this.x + (Math.random() * 100 - 50),
                this.y + (Math.random() * 100 - 50),
                Math.random() * 4 - 2,
                Math.random() * 2 + 1,
                ITEM_TYPES.POINT
            ));
        }
        
        // 掉落特殊资源
        for (let i = 0; i < 6; i++) {
            const resourceType = ITEM_TYPES.SPIRIT + (i % 3);
            items.push(new Item(
                this.x + (Math.random() * 80 - 40),
                this.y + (Math.random() * 80 - 40),
                Math.random() * 4 - 2,
                Math.random() * 2 + 1,
                resourceType
            ));
        }
        
        // 掉落炸弹和生命
        items.push(new Item(this.x - 30, this.y, 0, 1, ITEM_TYPES.BOMB));
        items.push(new Item(this.x + 30, this.y, 0, 1, ITEM_TYPES.LIFE));
        
        // 掉落满火力道具
        items.push(new Item(this.x, this.y - 30, 0, 1, ITEM_TYPES.FULL_POWER));
    }
    
    hit(damage) {
        if (this.invincible) return false;
        
        // Boss受伤
        this.health -= damage;
        
        // 如果在符卡阶段，也减少符卡生命值
        if (this.currentSpell >= 0 && this.currentSpell < this.spellCards.length) {
            const spell = this.spellCards[this.currentSpell];
            if (spell.active) {
                spell.health -= damage;
            }
        }
        
        // 添加命中效果
        effects.push(new Effect(this.x, this.y, EFFECT_TYPES.HIT, 10));
        
        // 增加连击
        GAME_STATE.combo++;
        GAME_STATE.maxCombo = Math.max(GAME_STATE.combo, GAME_STATE.maxCombo);
        
        return this.health <= 0;
    }
    
    draw() {
        gameCtx.save();
        
        if (this.behaviorState === "intro") {
            // 入场动画
            const introProgress = (180 - this.introTime) / 180;
            const scale = Math.min(1, introProgress * 1.5);
            const alpha = Math.min(1, introProgress * 2);
            
            gameCtx.globalAlpha = alpha;
            
            // 光环效果
            const radius = this.width * (1 + Math.sin(this.appearEffect * 0.1) * 0.2);
            gameCtx.fillStyle = "#ffffff";
            gameCtx.globalAlpha = 0.3 * alpha;
            gameCtx.beginPath();
            gameCtx.arc(this.x, this.y, radius * 1.5, 0, Math.PI * 2);
            gameCtx.fill();
            
            // 闪烁效果
            if (this.appearEffect % 10 < 5) {
                gameCtx.fillStyle = "#ffff88";
                gameCtx.globalAlpha = 0.7 * alpha;
                gameCtx.beginPath();
                gameCtx.arc(this.x, this.y, radius * 1.2, 0, Math.PI * 2);
                gameCtx.fill();
            }
            
            // 主体
            gameCtx.globalAlpha = alpha;
            const bossColors = {
                "露米娅": "#aa5588",
                "琪露诺": "#55aaff",
                "蕾米莉亚": "#cc0000"
            };
            
            gameCtx.fillStyle = bossColors[this.name] || "#ffffff";
            gameCtx.beginPath();
            gameCtx.arc(this.x, this.y, radius, 0, Math.PI * 2);
            gameCtx.fill();
        }
        else if (this.behaviorState === "defeated") {
            // 死亡动画
            const deathProgress = this.deathAnimation / 180;
            
            // 爆炸效果
            for (let i = 0; i < 5; i++) {
                const explosionSize = (20 + i * 15) * deathProgress;
                const explosionAlpha = Math.max(0, 1 - deathProgress * 1.5);
                
                gameCtx.globalAlpha = explosionAlpha * (0.8 - i * 0.15);
                gameCtx.fillStyle = i % 2 === 0 ? "#ffffff" : "#ffaa00";
                gameCtx.beginPath();
                gameCtx.arc(
                    this.x + Math.sin(this.deathAnimation * 0.1 + i) * 10, 
                    this.y + Math.cos(this.deathAnimation * 0.1 + i) * 10, 
                    explosionSize, 
                    0, Math.PI * 2
                );
                gameCtx.fill();
            }
            
            // 闪烁的主体
            if (this.deathAnimation % 10 < 5) {
                gameCtx.globalAlpha = Math.max(0, 1 - deathProgress * 2);
                gameCtx.fillStyle = "#ffffff";
                gameCtx.beginPath();
                gameCtx.arc(this.x, this.y, this.width, 0, Math.PI * 2);
                gameCtx.fill();
            }
        }
        else {
            // 正常状态
            let bossColor;
            switch(this.name) {
                case "露米娅":
                    bossColor = "#aa5588";
                    break;
                case "琪露诺":
                    bossColor = "#55aaff";
                    break;
                case "蕾米莉亚":
                    bossColor = "#cc0000";
                    break;
                default:
                    bossColor = "#ffffff";
            }
            
            // 绘制Boss主体
            gameCtx.fillStyle = bossColor;
            gameCtx.beginPath();
            gameCtx.arc(this.x, this.y, this.width / 2, 0, Math.PI * 2);
            gameCtx.fill();
            
            // 内部细节
            gameCtx.fillStyle = "#ffffff";
            gameCtx.globalAlpha = 0.7;
            gameCtx.beginPath();
            gameCtx.arc(this.x, this.y, this.width / 4, 0, Math.PI * 2);
            gameCtx.fill();
            
            // 外部环
            gameCtx.globalAlpha = 0.3;
            gameCtx.beginPath();
            gameCtx.arc(this.x, this.y, this.width / 1.5, 0, Math.PI * 2);
            gameCtx.fill();
            
            // 符卡模式的特殊效果
            if (this.currentSpell >= 0 && this.spellCards[this.currentSpell].active) {
                // 符卡光环
                gameCtx.globalAlpha = 0.5 + 0.3 * Math.sin(this.animation * 0.1);
                gameCtx.fillStyle = "#ffaa00";
                gameCtx.beginPath();
                gameCtx.arc(this.x, this.y, this.width * (0.8 + 0.2 * Math.sin(this.animation * 0.1)), 0, Math.PI * 2);
                gameCtx.fill();
                
                // 符卡能量线
                gameCtx.strokeStyle = "#ffff00";
                gameCtx.lineWidth = 2;
                gameCtx.globalAlpha = 0.7;
                
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + this.animation * 0.02;
                    const outerRadius = this.width * (1.2 + 0.3 * Math.sin(this.animation * 0.1 + i));
                    
                    gameCtx.beginPath();
                    gameCtx.moveTo(
                        this.x + Math.cos(angle) * this.width * 0.6,
                        this.y + Math.sin(angle) * this.width * 0.6
                    );
                    gameCtx.lineTo(
                        this.x + Math.cos(angle) * outerRadius,
                        this.y + Math.sin(angle) * outerRadius
                    );
                    gameCtx.stroke();
                }
            }
            
            // 过渡动画
            if (this.behaviorState === "transition") {
                const transitionProgress = (90 - this.behaviorTime) / 90;
                
                // 闪烁效果
                if (Math.floor(transitionProgress * 10) % 2 === 0) {
                    gameCtx.globalAlpha = 0.8;
                    gameCtx.fillStyle = "#ffffff";
                    gameCtx.beginPath();
                    gameCtx.arc(this.x, this.y, this.width * 0.7, 0, Math.PI * 2);
                    gameCtx.fill();
                }
                
                // 能量光环
                gameCtx.globalAlpha = 0.5;
                gameCtx.fillStyle = "#ffaa00";
                gameCtx.beginPath();
                gameCtx.arc(this.x, this.y, this.width * (1 + transitionProgress), 0, Math.PI * 2);
                gameCtx.fill();
            }
        }
        
        // 绘制生命条
        if (this.behaviorState !== "intro" && this.behaviorState !== "defeated") {
            const healthBarWidth = 200;
            const healthBarHeight = 10;
            const healthPercent = this.health / this.maxHealth;
            
            // 背景
            gameCtx.globalAlpha = 0.7;
            gameCtx.fillStyle = "#333333";
            gameCtx.fillRect(
                gameCanvas.width / 2 - healthBarWidth / 2,
                30,
                healthBarWidth,
                healthBarHeight
            );
            
            // 生命值
            gameCtx.globalAlpha = 1;
            gameCtx.fillStyle = healthPercent > 0.5 ? "#00ff00" : healthPercent > 0.25 ? "#ffff00" : "#ff0000";
            gameCtx.fillRect(
                gameCanvas.width / 2 - healthBarWidth / 2,
                30,
                healthBarWidth * healthPercent,
                healthBarHeight
            );
            
            // 分段标记
            for (let i = 1; i < this.spellCards.length; i++) {
                const markerX = gameCanvas.width / 2 - healthBarWidth / 2 + healthBarWidth * (1 - i / this.spellCards.length);
                
                gameCtx.fillStyle = "#ffffff";
                gameCtx.fillRect(
                    markerX,
                    28,
                    2,
                    healthBarHeight + 4
                );
            }
            
            // 显示名称
            gameCtx.globalAlpha = 1;
            gameCtx.fillStyle = "#ffffff";
            gameCtx.font = "16px Arial";
            gameCtx.textAlign = "center";
            gameCtx.fillText(
                `${this.name} - ${this.title}`,
                gameCanvas.width / 2,
                20
            );
            
            // 如果在符卡阶段，显示符卡信息
            if (this.currentSpell >= 0 && this.spellCards[this.currentSpell].active) {
                const spell = this.spellCards[this.currentSpell];
                
                // 符卡进度条
                const spellBarWidth = 150;
                const spellBarHeight = 6;
                const spellTimePercent = spell.remainingTime / (spell.timeout * 60);
                
                // 背景
                gameCtx.globalAlpha = 0.5;
                gameCtx.fillStyle = "#333333";
                gameCtx.fillRect(
                    gameCanvas.width / 2 - spellBarWidth / 2,
                    45,
                    spellBarWidth,
                    spellBarHeight
                );
                
                // 时间
                gameCtx.globalAlpha = 0.8;
                gameCtx.fillStyle = spellTimePercent > 0.5 ? "#00ffff" : spellTimePercent > 0.25 ? "#ffff00" : "#ff0000";
                gameCtx.fillRect(
                    gameCanvas.width / 2 - spellBarWidth / 2,
                    45,
                    spellBarWidth * spellTimePercent,
                    spellBarHeight
                );
                
                // 符卡名称
                gameCtx.globalAlpha = 1;
                gameCtx.fillStyle = "#ffff88";
                gameCtx.font = "12px Arial";
                gameCtx.textAlign = "center";
                gameCtx.fillText(
                    spell.name,
                    gameCanvas.width / 2,
                    60
                );
                
                // 奖励显示
                gameCtx.fillStyle = "#88ff88";
                gameCtx.font = "10px Arial";
                gameCtx.fillText(
                    `奖励: ${spell.bonus} + ${this.captureBonus}`,
                    gameCanvas.width / 2,
                    75
                );
            }
        }
        
        // 对话头像
        if (this.portriatAlpha > 0 && this.currentDialogue) {
            gameCtx.globalAlpha = this.portriatAlpha;
            
            // 头像背景
            gameCtx.fillStyle = "#000000";
            gameCtx.globalAlpha = this.portriatAlpha * 0.7;
            gameCtx.fillRect(
                10,
                gameCanvas.height - 110,
                gameCanvas.width - 20,
                100
            );
            
            // 对话文本
            gameCtx.globalAlpha = this.portriatAlpha;
            gameCtx.fillStyle = "#ffffff";
            gameCtx.font = "16px Arial";
            gameCtx.textAlign = "left";
            gameCtx.fillText(
                this.currentDialogue.text,
                30,
                gameCanvas.height - 60
            );
            
            // 名称
            gameCtx.fillStyle = "#ffff88";
            gameCtx.font = "14px Arial";
            gameCtx.fillText(
                this.name,
                30,
                gameCanvas.height - 85
            );
        }
        
        gameCtx.restore();
    }
}

// 物品类
class Item {
    constructor(x, y, vx, vy, type) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.type = type;
        this.radius = 10;
        this.collected = false;
        this.animation = 0;
        this.magnetized = false;
    }
    
    update() {
        this.animation = (this.animation + 1) % 60;
        
        if (this.magnetized && player) {
            // 物品被磁化，朝玩家移动
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 0) {
                this.x += dx * 0.1;
                this.y += dy * 0.1;
            }
        } else {
            // 正常移动
            this.x += this.vx;
            this.y += this.vy;
            
            // 重力效果
            this.vy += 0.05;
            
            // 减速
            this.vx *= 0.98;
            
            // 反弹
            if (this.x < this.radius || this.x > gameCanvas.width - this.radius) {
                this.vx = -this.vx * 0.8;
                this.x = this.x < this.radius ? this.radius : gameCanvas.width - this.radius;
            }
            
            // 检查边界 - 确保物品不会掉出底部
            if (this.y > gameCanvas.height - this.radius) {
                this.y = gameCanvas.height - this.radius;
                this.vy = -this.vy * 0.5;
                
                // 如果弹跳太弱，就停止
                if (Math.abs(this.vy) < 0.5) {
                    this.vy = 0;
                }
            }
        }
        
        // 检查是否被收集
        if (player) {
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < this.radius + player.autoCollectRadius) {
                // 磁化物品
                this.magnetized = true;
            }
            
            if (distance < this.radius + player.width / 2) {
                this.collected = true;
                this.applyEffect();
                return true;
            }
        }
        
        // 检查是否超出屏幕
        return this.isOutOfBounds();
    }
    
    applyEffect() {
        switch(this.type) {
            case ITEM_TYPES.POWER:
                // 增加火力
                GAME_STATE.power = Math.min(CONFIG.MAX_POWER, GAME_STATE.power + CONFIG.POWER_STEP);
                GAME_STATE.powerLevel = Math.floor(GAME_STATE.power);
                
                // 添加效果
                effects.push(new Effect(this.x, this.y, EFFECT_TYPES.POWERUP, 30, "+Power"));
                break;
                
            case ITEM_TYPES.POINT:
                // 增加分数
                const pointValue = GAME_STATE.pointValue * 100;
                GAME_STATE.score += pointValue;
                
                // 添加效果
                effects.push(new Effect(this.x, this.y, EFFECT_TYPES.BONUS, 30, `+${pointValue}`));
                break;
                
            case ITEM_TYPES.LIFE:
                // 增加生命
                GAME_STATE.lives++;
                
                // 添加效果
                effects.push(new Effect(this.x, this.y, EFFECT_TYPES.POWERUP, 60, "+Life"));
                break;
                
            case ITEM_TYPES.BOMB:
                // 增加炸弹
                GAME_STATE.bombs++;
                
                // 添加效果
                effects.push(new Effect(this.x, this.y, EFFECT_TYPES.POWERUP, 60, "+Bomb"));
                break;
                
            case ITEM_TYPES.SPIRIT:
                // 增加灵力资源
                GAME_STATE.resources.spirit += 10;
                
                // 添加效果
                effects.push(new Effect(this.x, this.y, EFFECT_TYPES.POWERUP, 30, "+Spirit"));
                break;
                
            case ITEM_TYPES.FAITH:
                // 增加信仰资源
                GAME_STATE.resources.faith += 10;
                
                // 添加效果
                effects.push(new Effect(this.x, this.y, EFFECT_TYPES.POWERUP, 30, "+Faith"));
                break;
                
            case ITEM_TYPES.MAGIC:
                // 增加魔力资源
                GAME_STATE.resources.magic += 10;
                
                // 添加效果
                effects.push(new Effect(this.x, this.y, EFFECT_TYPES.POWERUP, 30, "+Magic"));
                break;
                
            case ITEM_TYPES.FULL_POWER:
                // 满火力
                GAME_STATE.power = CONFIG.MAX_POWER;
                GAME_STATE.powerLevel = Math.floor(GAME_STATE.power);
                
                // 添加效果
                effects.push(new Effect(this.x, this.y, EFFECT_TYPES.POWERUP, 60, "FULL POWER!"));
                break;
        }
    }
    
    isOutOfBounds() {
        return (
            this.x < -50 ||
            this.x > gameCanvas.width + 50 ||
            this.y < -50 ||
            this.y > gameCanvas.height + 50
        );
    }
    
    draw() {
        gameCtx.save();
        
        // 根据物品类型绘制不同的外观
        let color;
        let secondaryColor;
        let text;
        
        switch(this.type) {
            case ITEM_TYPES.POWER:
                color = "#ff0000";
                secondaryColor = "#ffaaaa";
                text = "P";
                break;
                
            case ITEM_TYPES.POINT:
                color = "#ffff00";
                secondaryColor = "#ffffaa";
                text = "S";
                break;
                
            case ITEM_TYPES.LIFE:
                color = "#00ff00";
                secondaryColor = "#aaffaa";
                text = "1UP";
                break;
                
            case ITEM_TYPES.BOMB:
                color = "#ff00ff";
                secondaryColor = "#ffaaff";
                text = "B";
                break;
                
            case ITEM_TYPES.SPIRIT:
                color = "#ff8800";
                secondaryColor = "#ffcc88";
                text = "Sp";
                break;
                
            case ITEM_TYPES.FAITH:
                color = "#00ffff";
                secondaryColor = "#aaffff";
                text = "Fa";
                break;
                
            case ITEM_TYPES.MAGIC:
                color = "#8800ff";
                secondaryColor = "#cc88ff";
                text = "Ma";
                break;
                
            case ITEM_TYPES.FULL_POWER:
                color = "#ffffff";
                secondaryColor = "#ffff88";
                text = "F";
                break;
        }
        
        // 物品闪烁效果
        const pulse = 1 + 0.2 * Math.sin(this.animation * 0.1);
        
        // 外层光晕
        gameCtx.globalAlpha = 0.5;
        gameCtx.fillStyle = secondaryColor;
        gameCtx.beginPath();
        gameCtx.arc(this.x, this.y, this.radius * 1.5 * pulse, 0, Math.PI * 2);
        gameCtx.fill();
        
        // 内层
        gameCtx.globalAlpha = 1;
        gameCtx.fillStyle = color;
        gameCtx.beginPath();
        gameCtx.arc(this.x, this.y, this.radius * pulse, 0, Math.PI * 2);
        gameCtx.fill();
        
        // 文字
        gameCtx.fillStyle = "#ffffff";
        gameCtx.font = "10px Arial";
        gameCtx.textAlign = "center";
        gameCtx.textBaseline = "middle";
        gameCtx.fillText(text, this.x, this.y);
        
        gameCtx.restore();
    }
}

// 效果类
class Effect {
    constructor(x, y, type, duration, text) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.duration = duration;
        this.remainingTime = duration;
        this.text = text;
        this.size = 0;
        this.alpha = 1;
        this.color = "#ffffff";
        
        // 根据类型设置不同的效果属性
        this.initializeType();
    }
    
    initializeType() {
        switch(this.type) {
            case EFFECT_TYPES.EXPLOSION:
                this.color = "#ff5500";
                this.size = 20;
                break;
                
            case EFFECT_TYPES.HIT:
                this.color = "#ffff00";
                this.size = 5;
                break;
                
            case EFFECT_TYPES.GRAZE:
                this.color = "#ffffff";
                this.size = 10;
                break;
                
            case EFFECT_TYPES.POWERUP:
                this.color = "#00ff00";
                this.size = 15;
                break;
                
            case EFFECT_TYPES.BONUS:
                this.color = "#ffff00";
                this.size = 12;
                // 文本效果向上飘动
                this.vy = -1;
                break;
                
            case EFFECT_TYPES.SPELL_START:
                this.color = "#ff00ff";
                this.size = 25;
                break;
                
            case EFFECT_TYPES.SPELL_END:
                this.color = "#00ffff";
                this.size = 20;
                // 文本效果向上飘动
                this.vy = -1.5;
                break;
                
            case EFFECT_TYPES.BOMB:
                this.color = "#ff88ff";
                this.size = 40;
                break;
        }
    }
    
    update() {
        this.remainingTime--;
        
        // 根据效果类型更新参数
        switch(this.type) {
            case EFFECT_TYPES.EXPLOSION:
                // 爆炸效果，扩大再消失
                this.size = 20 + (this.duration - this.remainingTime) * 1.5;
                this.alpha = this.remainingTime / this.duration;
                break;
                
            case EFFECT_TYPES.HIT:
                // 命中效果，快速消失
                this.alpha = this.remainingTime / this.duration;
                break;
                
            case EFFECT_TYPES.GRAZE:
                // 擦弹效果，扩大并淡出
                this.size = 10 + (this.duration - this.remainingTime) * 0.5;
                this.alpha = this.remainingTime / this.duration;
                break;
                
            case EFFECT_TYPES.POWERUP:
                // 能量效果，脉动并淡出
                this.size = 15 + 5 * Math.sin((this.duration - this.remainingTime) * 0.2);
                this.alpha = this.remainingTime / this.duration;
                break;
                
            case EFFECT_TYPES.BONUS:
                // 分数效果，向上飘动并淡出
                this.y += this.vy;
                this.alpha = this.remainingTime / this.duration;
                break;
                
            case EFFECT_TYPES.SPELL_START:
                // 符卡开始效果，扩大并闪烁
                this.size = 25 + (this.duration - this.remainingTime) * 1;
                this.alpha = 0.5 + 0.5 * Math.sin((this.duration - this.remainingTime) * 0.3);
                break;
                
            case EFFECT_TYPES.SPELL_END:
                // 符卡结束效果，向上飘动并淡出
                this.y += this.vy;
                this.alpha = this.remainingTime / this.duration;
                break;
                
            case EFFECT_TYPES.BOMB:
                // 炸弹效果，快速扩大再收缩
                const halfDuration = this.duration / 2;
                if (this.remainingTime > halfDuration) {
                    // 扩大阶段
                    this.size = 40 + (halfDuration - (this.remainingTime - halfDuration)) * 5;
                } else {
                    // 收缩阶段
                    this.size = 290 - (halfDuration - this.remainingTime) * 5;
                }
                this.alpha = this.remainingTime / this.duration;
                break;
        }
        
        return this.remainingTime <= 0;
    }
    
    draw() {
        gameCtx.save();
        
        gameCtx.globalAlpha = this.alpha;
        
        // 根据效果类型绘制不同的视觉效果
        switch(this.type) {
            case EFFECT_TYPES.EXPLOSION:
                // 爆炸效果 - 多层次的圆形
                gameCtx.fillStyle = "#ffffff";
                gameCtx.beginPath();
                gameCtx.arc(this.x, this.y, this.size * 0.5, 0, Math.PI * 2);
                gameCtx.fill();
                
                gameCtx.fillStyle = "#ffaa00";
                gameCtx.beginPath();
                gameCtx.arc(this.x, this.y, this.size * 0.8, 0, Math.PI * 2);
                gameCtx.fill();
                
                gameCtx.fillStyle = this.color;
                gameCtx.beginPath();
                gameCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                gameCtx.fill();
                break;
                
            case EFFECT_TYPES.HIT:
                // 命中效果 - 简单的小圆点
                gameCtx.fillStyle = this.color;
                gameCtx.beginPath();
                gameCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                gameCtx.fill();
                break;
                
            case EFFECT_TYPES.GRAZE:
                // 擦弹效果 - 淡色的环
                gameCtx.strokeStyle = this.color;
                gameCtx.lineWidth = 2;
                gameCtx.beginPath();
                gameCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                gameCtx.stroke();
                break;
                
            case EFFECT_TYPES.POWERUP:
                // 能量效果 - 星形
                gameCtx.fillStyle = this.color;
                gameCtx.beginPath();
                
                const spikes = 5;
                const outerRadius = this.size;
                const innerRadius = this.size * 0.4;
                
                for (let i = 0; i < spikes * 2; i++) {
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const angle = (i / (spikes * 2)) * Math.PI * 2;
                    const x = this.x + Math.cos(angle) * radius;
                    const y = this.y + Math.sin(angle) * radius;
                    
                    if (i === 0) {
                        gameCtx.moveTo(x, y);
                    } else {
                        gameCtx.lineTo(x, y);
                    }
                }
                
                gameCtx.closePath();
                gameCtx.fill();
                
                // 如果有文本，显示它
                if (this.text) {
                    gameCtx.fillStyle = "#ffffff";
                    gameCtx.font = "12px Arial";
                    gameCtx.textAlign = "center";
                    gameCtx.fillText(this.text, this.x, this.y + this.size + 10);
                }
                break;
                
            case EFFECT_TYPES.BONUS:
                // 分数效果 - 只显示文本
                if (this.text) {
                    gameCtx.fillStyle = this.color;
                    gameCtx.font = "14px Arial";
                    gameCtx.textAlign = "center";
                    gameCtx.fillText(this.text, this.x, this.y);
                }
                break;
                
            case EFFECT_TYPES.SPELL_START:
                // 符卡开始效果 - 扩散光环
                gameCtx.strokeStyle = this.color;
                gameCtx.lineWidth = 3;
                gameCtx.beginPath();
                gameCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                gameCtx.stroke();
                
                // 内部光芒
                gameCtx.globalAlpha = this.alpha * 0.7;
                gameCtx.fillStyle = "#ffffff";
                gameCtx.beginPath();
                gameCtx.arc(this.x, this.y, this.size * 0.7, 0, Math.PI * 2);
                gameCtx.fill();
                
                // 如果有文本，显示它
                if (this.text) {
                    gameCtx.globalAlpha = this.alpha;
                    gameCtx.fillStyle = "#ffffff";
                    gameCtx.font = "18px Arial";
                    gameCtx.textAlign = "center";
                    gameCtx.fillText(this.text, this.x, this.y - this.size - 10);
                }
                break;
                
            case EFFECT_TYPES.SPELL_END:
                // 符卡结束效果 - 特殊文本显示
                if (this.text) {
                    gameCtx.fillStyle = this.color;
                    gameCtx.font = "bold 18px Arial";
                    gameCtx.textAlign = "center";
                    gameCtx.fillText(this.text, this.x, this.y);
                }
                break;
                
            case EFFECT_TYPES.BOMB:
                // 炸弹效果 - 大型扩散波
                gameCtx.strokeStyle = this.color;
                gameCtx.lineWidth = 5 * this.alpha;
                gameCtx.beginPath();
                gameCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                gameCtx.stroke();
                
                // 内部光晕
                gameCtx.globalAlpha = this.alpha * 0.3;
                gameCtx.fillStyle = this.color;
                gameCtx.beginPath();
                gameCtx.arc(this.x, this.y, this.size * 0.9, 0, Math.PI * 2);
                gameCtx.fill();
                break;
        }
        
        gameCtx.restore();
    }
}

// 全局变量
let gameLoopInterval = null;
let lastTime = 0;
let deltaTime = 0;
const FPS_INTERVAL = 1000 / CONFIG.FPS;

// 舞台特效和障碍物
let stageEffects = [];
let stageObstacles = [];
let stageHazards = [];
let bossShadows = [];
let stageBats = [];
let stageFateCircles = [];

// 游戏初始化
function initGame() {
    // 设置事件监听器
    setupEventListeners();
    
    // 显示主菜单
    menu.style.display = "flex";
    
    // 保存高分
    if (localStorage.getItem('highScore')) {
        GAME_STATE.highScore = parseInt(localStorage.getItem('highScore'));
    }
}

// 设置事件监听器
function setupEventListeners() {
    // 键盘控制
    document.addEventListener('keydown', (e) => {
        switch(e.key) {
            case 'ArrowUp':
            case 'w':
            case 'W':
                KEYS.up = true;
                break;
            case 'ArrowDown':
            case 's':
            case 'S':
                KEYS.down = true;
                break;
            case 'ArrowLeft':
            case 'a':
            case 'A':
                KEYS.left = true;
                break;
            case 'ArrowRight':
            case 'd':
            case 'D':
                KEYS.right = true;
                break;
            case 'z':
            case 'Z':
            case ' ':
                KEYS.shoot = true;
                break;
            case 'Shift':
                KEYS.focus = true;
                if (player) player.isFocused = true;
                break;
            case 'x':
            case 'X':
                KEYS.bomb = true;
                break;
            case 'c':
            case 'C':
                KEYS.special = true;
                break;
            case 'Escape':
                if (GAME_STATE.isRunning) {
                    togglePause();
                }
                break;
        }
    });
    
    document.addEventListener('keyup', (e) => {
        switch(e.key) {
            case 'ArrowUp':
            case 'w':
            case 'W':
                KEYS.up = false;
                break;
            case 'ArrowDown':
            case 's':
            case 'S':
                KEYS.down = false;
                break;
            case 'ArrowLeft':
            case 'a':
            case 'A':
                KEYS.left = false;
                break;
            case 'ArrowRight':
            case 'd':
            case 'D':
                KEYS.right = false;
                break;
            case 'z':
            case 'Z':
            case ' ':
                KEYS.shoot = false;
                break;
            case 'Shift':
                KEYS.focus = false;
                if (player) player.isFocused = false;
                break;
            case 'x':
            case 'X':
                KEYS.bomb = false;
                break;
            case 'c':
            case 'C':
                KEYS.special = false;
                break;
        }
    });
    
    // 菜单按钮
    document.getElementById('start-game').addEventListener('click', () => {
        startNewGame();
    });
    
    document.getElementById('select-character').addEventListener('click', () => {
        showCharacterSelect();
    });
    
    document.getElementById('practice-mode').addEventListener('click', () => {
        startPracticeMode();
    });
    
    document.getElementById('spell-practice').addEventListener('click', () => {
        showSpellPractice();
    });
    
    document.getElementById('achievements').addEventListener('click', () => {
        showAchievements();
    });
    
    document.getElementById('options').addEventListener('click', () => {
        showOptions();
    });
}

// 开始新游戏
function startNewGame() {
    GAME_STATE.isRunning = true;
    GAME_STATE.isPaused = false;
    GAME_STATE.isGameOver = false;
    GAME_STATE.currentStage = 0;
    GAME_STATE.score = 0;
    GAME_STATE.graze = 0;
    GAME_STATE.power = 1.0;
    GAME_STATE.powerLevel = 1;
    GAME_STATE.lives = CONFIG.STARTING_LIVES;
    GAME_STATE.bombs = CONFIG.STARTING_BOMBS;
    GAME_STATE.rank = 0;
    GAME_STATE.pointValue = 10;
    GAME_STATE.combo = 0;
    GAME_STATE.maxCombo = 0;
    GAME_STATE.stageTimer = 0;
    GAME_STATE.resources = {
        spirit: 0,
        faith: 0,
        magic: 0
    };
    GAME_STATE.replayData = [];
    GAME_STATE.replayMode = false;
    GAME_STATE.specialMechanics = {
        bulletTime: false,
        shieldActive: false,
        perfectDodge: false,
        counterAttack: false,
        resonance: 0
    };
    
    // 隐藏菜单
    menu.style.display = "none";
    
    // 创建玩家
    player = new Player(GAME_STATE.selectedCharacter);
    
    // 清空所有实体
    playerBullets = [];
    enemies = [];
    bosses = [];
    enemyBullets = [];
    items = [];
    effects = [];
    stageEffects = [];
    stageObstacles = [];
    stageHazards = [];
    bossShadows = [];
    stageBats = [];
    stageFateCircles = [];
    
    // 开始游戏循环
    startGameLoop();
    
    // 加载第一关
    loadStage(0);
}

// 开始练习模式
function startPracticeMode() {
    GAME_STATE.mode = 'PRACTICE';
    GAME_STATE.isRunning = true;
    GAME_STATE.isPaused = false;
    GAME_STATE.isGameOver = false;
    GAME_STATE.score = 0;
    GAME_STATE.graze = 0;
    GAME_STATE.power = 4.0; // 满火力
    GAME_STATE.powerLevel = 4;
    GAME_STATE.lives = 5; // 额外生命
    GAME_STATE.bombs = 5; // 额外炸弹
    GAME_STATE.rank = 50; // 中等难度
    GAME_STATE.pointValue = 10;
    GAME_STATE.combo = 0;
    GAME_STATE.maxCombo = 0;
    GAME_STATE.stageTimer = 0;
    GAME_STATE.resources = {
        spirit: 50,
        faith: 50,
        magic: 50
    };
    GAME_STATE.replayData = [];
    GAME_STATE.replayMode = false;
    GAME_STATE.specialMechanics = {
        bulletTime: false,
        shieldActive: false,
        perfectDodge: false,
        counterAttack: false,
        resonance: 0
    };
    
    // 隐藏菜单
    menu.style.display = "none";
    
    // 创建玩家
    player = new Player(GAME_STATE.selectedCharacter);
    
    // 清空所有实体
    playerBullets = [];
    enemies = [];
    bosses = [];
    enemyBullets = [];
    items = [];
    effects = [];
    stageEffects = [];
    stageObstacles = [];
    stageHazards = [];
    bossShadows = [];
    stageBats = [];
    stageFateCircles = [];
    
    // 开始游戏循环
    startGameLoop();
    
    // 选择练习的关卡
    showStageSelect();
}

// 开始符卡练习
function startSpellPractice() {
    if (!GAME_STATE.practiceSpell) return;
    
    GAME_STATE.mode = 'SPELL_PRACTICE';
    GAME_STATE.isRunning = true;
    GAME_STATE.isPaused = false;
    GAME_STATE.isGameOver = false;
    GAME_STATE.score = 0;
    GAME_STATE.graze = 0;
    GAME_STATE.power = 4.0; // 满火力
    GAME_STATE.powerLevel = 4;
    GAME_STATE.lives = 5; // 额外生命
    GAME_STATE.bombs = 5; // 额外炸弹
    GAME_STATE.rank = 50; // 中等难度
    GAME_STATE.pointValue = 10;
    GAME_STATE.combo = 0;
    GAME_STATE.maxCombo = 0;
    GAME_STATE.stageTimer = 0;
    GAME_STATE.resources = {
        spirit: 50,
        faith: 50,
        magic: 50
    };
    GAME_STATE.replayData = [];
    GAME_STATE.replayMode = false;
    GAME_STATE.specialMechanics = {
        bulletTime: false,
        shieldActive: false,
        perfectDodge: false,
        counterAttack: false,
        resonance: 0
    };
    
    // 隐藏菜单
    menu.style.display = "none";
    
    // 创建玩家
    player = new Player(GAME_STATE.selectedCharacter);
    
    // 清空所有实体
    playerBullets = [];
    enemies = [];
    bosses = [];
    enemyBullets = [];
    items = [];
    effects = [];
    stageEffects = [];
    stageObstacles = [];
    stageHazards = [];
    bossShadows = [];
    stageBats = [];
    stageFateCircles = [];
    
    // 开始游戏循环
    startGameLoop();
    
    // 直接加载选择的符卡
    loadSpellPractice(GAME_STATE.practiceSpell);
}

// 加载符卡练习
function loadSpellPractice(spellData) {
    // 创建Boss并直接进入符卡模式
    const bossInfo = STAGES.find(stage => stage.boss.name === spellData.boss).boss;
    
    const boss = new Boss(bossInfo);
    boss.x = gameCanvas.width / 2;
    boss.y = 150;
    
    // 找到符卡索引
    const spellIndex = bossInfo.spellCards.findIndex(spell => spell.name === spellData.name);
    
    if (spellIndex >= 0) {
        // 跳过入场动画
        boss.behaviorState = "normal";
        boss.introTime = 0;
        
        // 直接开始符卡
        setTimeout(() => {
            boss.startSpellcard(spellIndex);
        }, 1000);
        
        bosses.push(boss);
    }
}

// 游戏循环
function startGameLoop() {
    if (gameLoopInterval) {
        clearInterval(gameLoopInterval);
    }
    
    lastTime = performance.now();
    
    gameLoopInterval = setInterval(() => {
        if (!GAME_STATE.isPaused) {
            const now = performance.now();
            deltaTime = now - lastTime;
            
            if (deltaTime >= FPS_INTERVAL) {
                lastTime = now - (deltaTime % FPS_INTERVAL);
                
                update();
                draw();
                
                // 保存回放数据
                if (GAME_STATE.stageTimer % CONFIG.REPLAY_FRAMES_INTERVAL === 0) {
                    saveReplayFrame();
                }
            }
        }
    }, 1);
}

// 更新游戏状态
function update() {
    if (!GAME_STATE.isRunning || GAME_STATE.isGameOver) return;
    
    // 更新计时器
    GAME_STATE.stageTimer++;
    
    // 根据关卡计时器生成敌人
    if (GAME_STATE.mode === 'GAME' || GAME_STATE.mode === 'PRACTICE') {
        spawnEnemies();
    }
    
    // 更新玩家
    if (player) {
        player.update();
        
        // 检查玩家与子弹的碰撞
        enemyBullets = enemyBullets.filter(bullet => {
            // 检查玩家是否碰到子弹
            if (player.checkCollision(bullet)) {
                player.hit();
                return false; // 移除子弹
            }
            
            // 更新子弹，如果返回true则表示子弹超出边界
            return !bullet.update();
        });
    }
    
    // 更新玩家子弹
    playerBullets = playerBullets.filter(bullet => {
        // 检查子弹是否击中敌人
        let bulletHit = false;
        
        // 检查敌人碰撞
        enemies.forEach(enemy => {
            const dx = enemy.x - bullet.x;
            const dy = enemy.y - bullet.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < enemy.width / 2 + bullet.radius) {
                enemy.hit(bullet.damage);
                bulletHit = true;
            }
        });
        
        // 检查Boss碰撞
        bosses.forEach(boss => {
            const dx = boss.x - bullet.x;
            const dy = boss.y - bullet.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < boss.width / 2 + bullet.radius) {
                boss.hit(bullet.damage);
                bulletHit = true;
            }
        });
        
        // 更新子弹，如果返回true则表示子弹超出边界
        return !bullet.update() && !bulletHit;
    });
    
    // 更新敌人
    enemies = enemies.filter(enemy => !enemy.update());
    
    // 更新Boss
    bosses = bosses.filter(boss => !boss.update());
    
    // 更新物品
    items = items.filter(item => !item.update());
    
    // 更新效果
    effects = effects.filter(effect => !effect.update());
    
    // 更新舞台特效
    updateStageEffects();
    
    // 检查关卡完成
    checkStageComplete();
    
    // 更新难度等级
    updateRank();
    
    // 检查成就
    checkAchievements();
}

// 更新舞台特效
function updateStageEffects() {
    // 更新舞台效果
    stageEffects = stageEffects.filter(effect => {
        effect.current++;
        
        if (effect.current < effect.duration) {
            // 淡入
            if (effect.current < effect.duration * 0.2) {
                effect.alpha = (effect.current / (effect.duration * 0.2)) * effect.maxAlpha;
            }
            // 淡出
            else if (effect.current > effect.duration * 0.8) {
                effect.alpha = ((effect.duration - effect.current) / (effect.duration * 0.2)) * effect.maxAlpha;
            }
            // 保持
            else {
                effect.alpha = effect.maxAlpha;
            }
            
            return true;
        }
        
        return false;
    });
    
    // 更新障碍物
    stageObstacles = stageObstacles.filter(obstacle => {
        obstacle.lifetime--;
        
        // 淡入
        if (obstacle.lifetime > obstacle.lifetime * 0.8) {
            obstacle.alpha = (obstacle.lifetime - obstacle.lifetime * 0.8) / (obstacle.lifetime * 0.2);
        }
        // 淡出
        else if (obstacle.lifetime < obstacle.lifetime * 0.2) {
            obstacle.alpha = obstacle.lifetime / (obstacle.lifetime * 0.2);
        }
        // 保持
        else {
            obstacle.alpha = 1;
        }
        
        // 检查与玩家的碰撞
        if (player && obstacle.alpha > 0.5) {
            const dx = player.x - obstacle.x;
            const dy = player.y - obstacle.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < (obstacle.width + obstacle.height) / 4 + player.width / 2) {
                // 玩家被障碍物阻挡，退回上一位置
                player.x = player.lastPosition.x;
                player.y = player.lastPosition.y;
            }
        }
        
        return obstacle.lifetime > 0;
    });
    
    // 更新危险区域
    stageHazards = stageHazards.filter(hazard => {
        hazard.lifetime--;
        
        // 淡入
        if (hazard.lifetime > hazard.lifetime * 0.8) {
            hazard.alpha = (hazard.lifetime - hazard.lifetime * 0.8) / (hazard.lifetime * 0.2);
        }
        // 淡出
        else if (hazard.lifetime < hazard.lifetime * 0.2) {
            hazard.alpha = hazard.lifetime / (hazard.lifetime * 0.2);
        }
        // 保持
        else {
            hazard.alpha = 0.5;
        }
        
        // 检查玩家是否在减速区域内
        if (player && hazard.alpha > 0.3) {
            const dx = player.x - hazard.x;
            const dy = player.y - hazard.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < hazard.radius) {
                // 减速玩家
                player.speed *= hazard.slowFactor;
                player.focusSpeed *= hazard.slowFactor;
            }
        }
        
        return hazard.lifetime > 0;
    });
    
    // 更新Boss分身
    bossShadows = bossShadows.filter(shadow => {
        shadow.lifetime--;
        
        // 移动到目标位置
        const dx = shadow.targetX - shadow.x;
        const dy = shadow.targetY - shadow.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 2) {
            shadow.x += dx * 0.05;
            shadow.y += dy * 0.05;
        }
        
        // 淡出
        if (shadow.lifetime < 50) {
            shadow.alpha = shadow.lifetime / 50;
        }
        
        return shadow.lifetime > 0;
    });
    
    // 更新蝙蝠
    stageBats = stageBats.filter(bat => {
        bat.lifetime--;
        
        // 移动蝙蝠
        bat.x += bat.speedX;
        bat.y += bat.speedY;
        
        // 随机改变方向
        if (Math.random() < 0.05) {
            bat.speedX += (Math.random() - 0.5) * 0.5;
            bat.speedX = Math.max(-2, Math.min(2, bat.speedX));
        }
        
        // 检查是否射击
        if (bat.canShoot && bat.nextShoot <= 0) {
            // 射出1-3颗子弹
            const bulletCount = 1 + Math.floor(Math.random() * 3);
            
            for (let i = 0; i < bulletCount; i++) {
                const angle = Math.PI / 2 + (Math.random() - 0.5) * Math.PI / 4; // 向下略微扩散
                const speed = CONFIG.BULLET_SPEED * 0.6;
                
                enemyBullets.push(new Bullet(
                    bat.x, bat.y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    BULLET_TYPES.ENEMY_SMALL,
                    CONFIG.ENEMY_BULLET_SIZE * 0.6, 1, "#ff0000"
                ));
            }
            
            bat.nextShoot = 60 + Math.random() * 60;
        } else {
            bat.nextShoot--;
        }
        
        // 检查与玩家的碰撞
        if (player) {
            const dx = player.x - bat.x;
            const dy = player.y - bat.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < bat.size + player.width / 2) {
                // 玩家被蝙蝠撞到
                player.hit();
                return false; // 移除蝙蝠
            }
        }
        
        return bat.lifetime > 0 && bat.y < gameCanvas.height + 20;
    });
    
    // 更新命运圈
    stageFateCircles = stageFateCircles.filter(circle => {
        circle.lifetime--;
        
        // 旋转圈
        circle.currentAngle += circle.rotationSpeed;
        
        // 检查是否射击
        if (circle.nextShoot <= 0) {
            // 射出围绕圆周的子弹
            for (let i = 0; i < circle.bulletCount; i++) {
                const angle = circle.currentAngle + (i / circle.bulletCount) * Math.PI * 2;
                const x = circle.centerX + Math.cos(angle) * circle.radius;
                const y = circle.centerY + Math.sin(angle) * circle.radius;
                
                // 子弹向外发射
                const speed = CONFIG.BULLET_SPEED * 0.7;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                
                enemyBullets.push(new Bullet(
                    x, y,
                    vx, vy,
                    BULLET_TYPES.ENEMY_NORMAL,
                    CONFIG.ENEMY_BULLET_SIZE, 1, "#ff5500"
                ));
            }
            
            circle.nextShoot = circle.shootInterval;
        } else {
            circle.nextShoot--;
        }
        
        // 检查玩家是否碰到圆环
        if (player) {
            const dx = player.x - circle.centerX;
            const dy = player.y - circle.centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (Math.abs(distance - circle.radius) < player.width / 2) {
                // 玩家碰到圆环
                player.hit();
            }
        }
        
        return circle.lifetime > 0;
    });
}

// 生成敌人
function spawnEnemies() {
    const stage = STAGES[GAME_STATE.currentStage];
    
    if (!stage) return;
    
    // 检查每个敌人组的生成时间
    stage.enemies.forEach(enemyGroup => {
        if (GAME_STATE.stageTimer === enemyGroup.delay * 60) {
            // 生成该组敌人
            for (let i = 0; i < enemyGroup.count; i++) {
                let x, y;
                
                switch(enemyGroup.pattern) {
                    case "line":
                        x = 50 + (gameCanvas.width - 100) * (i / (enemyGroup.count - 1 || 1));
                        y = -30;
                        break;
                    case "v":
                        x = 50 + (gameCanvas.width - 100) * (i / (enemyGroup.count - 1 || 1));
                        y = -30 - (i % 2) * 30;
                        break;
                    case "circle":
                        const angle = (i / enemyGroup.count) * Math.PI * 2;
                        x = gameCanvas.width / 2 + Math.cos(angle) * 30;
                        y = -50;
                        break;
                    case "random":
                        x = 50 + Math.random() * (gameCanvas.width - 100);
                        y = -30 - Math.random() * 50;
                        break;
                    case "triangle":
                        if (i % 3 === 0) {
                            x = gameCanvas.width / 2;
                            y = -30;
                        } else if (i % 3 === 1) {
                            x = gameCanvas.width / 2 - 50 - (i / enemyGroup.count) * 50;
                            y = -30 - 40;
                        } else {
                            x = gameCanvas.width / 2 + 50 + (i / enemyGroup.count) * 50;
                            y = -30 - 40;
                        }
                        break;
                    case "wave":
                        x = 50 + (gameCanvas.width - 100) * (i / (enemyGroup.count - 1 || 1));
                        y = -30 - Math.sin(i * 0.5) * 30;
                        break;
                    case "cross":
                        if (i < enemyGroup.count / 2) {
                            x = 50 + (gameCanvas.width - 100) * (i / (enemyGroup.count / 2 - 1 || 1));
                            y = -30;
                        } else {
                            x = gameCanvas.width / 2;
                            y = -30 - (i - enemyGroup.count / 2) * 20;
                        }
                        break;
                    case "spiral":
                        const spiralAngle = (i / enemyGroup.count) * Math.PI * 10;
                        const spiralRadius = 10 + i * 5;
                        x = gameCanvas.width / 2 + Math.cos(spiralAngle) * spiralRadius;
                        y = -50 - Math.sin(spiralAngle) * spiralRadius;
                        break;
                    case "diamond":
                        const diamondAngle = (i / enemyGroup.count) * Math.PI * 2;
                        x = gameCanvas.width / 2 + Math.cos(diamondAngle) * 30;
                        y = -50 + Math.sin(diamondAngle) * 15;
                        break;
                    case "center":
                        x = gameCanvas.width / 2;
                        y = -50;
                        break;
                    case "formation":
                        x = 50 + (gameCanvas.width - 100) * (i / (enemyGroup.count - 1 || 1));
                        y = -30 - (i % 3) * 20;
                        break;
                    case "square":
                        if (i < enemyGroup.count / 4) {
                            x = 50 + (gameCanvas.width - 100) * (i / (enemyGroup.count / 4 - 1 || 1));
                            y = -30;
                        } else if (i < enemyGroup.count / 2) {
                            x = gameCanvas.width - 50;
                            y = -30 + (gameCanvas.height / 2) * ((i - enemyGroup.count / 4) / (enemyGroup.count / 4 - 1 || 1));
                        } else if (i < enemyGroup.count * 3/4) {
                            x = gameCanvas.width - 50 - (gameCanvas.width - 100) * ((i - enemyGroup.count / 2) / (enemyGroup.count / 4 - 1 || 1));
                            y = gameCanvas.height / 2 - 30;
                        } else {
                            x = 50;
                            y = gameCanvas.height / 2 - 30 - (gameCanvas.height / 2) * ((i - enemyGroup.count * 3/4) / (enemyGroup.count / 4 - 1 || 1));
                        }
                        break;
                    case "diagonal":
                        if (i < enemyGroup.count / 2) {
                            x = 50 + (gameCanvas.width - 100) * (i / (enemyGroup.count / 2 - 1 || 1));
                            y = -30 - (gameCanvas.height / 3) * (i / (enemyGroup.count / 2 - 1 || 1));
                        } else {
                            x = 50 + (gameCanvas.width - 100) * (1 - (i - enemyGroup.count / 2) / (enemyGroup.count / 2 - 1 || 1));
                            y = -30 - (gameCanvas.height / 3) * (1 - (i - enemyGroup.count / 2) / (enemyGroup.count / 2 - 1 || 1));
                        }
                        break;
                    default:
                        x = 50 + (gameCanvas.width - 100) * (i / (enemyGroup.count - 1 || 1));
                        y = -30;
                }
                
                // 创建敌人
                const enemy = new Enemy(x, y, enemyGroup.type, enemyGroup.pattern);
                enemies.push(enemy);
            }
        }
    });
    
    // 检查Boss生成时间（最后一组敌人后的10秒）
    const lastEnemyGroup = stage.enemies[stage.enemies.length - 1];
    const bossSpawnTime = (lastEnemyGroup.delay + 10) * 60;
    
    if (GAME_STATE.stageTimer === bossSpawnTime && bosses.length === 0) {
        // 生成Boss
        const boss = new Boss(stage.boss);
        bosses.push(boss);
    }
    
    // 检查舞台特殊机制
    if (stage.hazards) {
        stage.hazards.forEach(hazard => {
            if (GAME_STATE.stageTimer === hazard.delay * 60) {
                // 触发舞台特殊机制
                triggerStageHazard(hazard);
            }
        });
    }
}

// 触发舞台机制
function triggerStageHazard(hazard) {
    switch(hazard.type) {
        case "fog":
            // 创建迷雾效果
            stageEffects.push({
                type: "fog",
                alpha: 0,
                maxAlpha: 0.5,
                duration: hazard.duration * 60,
                current: 0
            });
            break;
            
        case "wind":
            // 创建风效果，推动玩家
            const windEffect = {
                type: "wind",
                direction: hazard.direction,
                alpha: 0,
                maxAlpha: 0.7,
                duration: hazard.duration * 60,
                current: 0,
                force: hazard.direction === "left" ? -0.5 : 0.5
            };
            
            stageEffects.push(windEffect);
            break;
            
        case "ice":
            // 创建冰面效果，使玩家滑动
            stageEffects.push({
                type: "ice",
                alpha: 0,
                maxAlpha: 0.5,
                duration: hazard.duration * 60,
                current: 0
            });
            
            // 创建冰块障碍
            for (let i = 0; i < 5; i++) {
                stageObstacles.push({
                    x: 100 + Math.random() * (gameCanvas.width - 200),
                    y: 200 + Math.random() * (gameCanvas.height - 400),
                    width: 30 + Math.random() * 20,
                    height: 30 + Math.random() * 20,
                    lifetime: hazard.duration * 60,
                    alpha: 0,
                    rotation: Math.random() * Math.PI * 2
                });
            }
            break;
            
        case "blizzard":
            // 创建暴风雪效果，使玩家视野下降并随机生成冰弹
            stageEffects.push({
                type: "blizzard",
                alpha: 0,
                maxAlpha: 0.6,
                duration: hazard.duration * 60,
                current: 0
            });
            
            // 定时生成冰弹
            const blizzardInterval = setInterval(() => {
                // 随机位置生成冰弹
                for (let i = 0; i < 5; i++) {
                    const x = Math.random() * gameCanvas.width;
                    const y = -20;
                    const angle = Math.PI / 2 + (Math.random() - 0.5) * Math.PI / 4; // 向下略微扩散
                    const speed = CONFIG.BULLET_SPEED * 0.7;
                    
                    enemyBullets.push(new Bullet(
                        x, y,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        BULLET_TYPES.ENEMY_SMALL,
                        CONFIG.ENEMY_BULLET_SIZE * 0.7, 1, "#88ccff"
                    ));
                }
            }, 1000);
            
            // 停止暴风雪
            setTimeout(() => {
                clearInterval(blizzardInterval);
            }, hazard.duration * 1000);
            break;
            
        case "darkness":
            // 创建黑暗效果，降低可见度
            stageEffects.push({
                type: "darkness",
                alpha: 0,
                maxAlpha: 0.8,
                duration: hazard.duration * 60,
                current: 0
            });
            break;
            
        case "bats":
            // 生成蝙蝠群
            const batCount = 20;
            
            for (let i = 0; i < batCount; i++) {
                setTimeout(() => {
                    const bat = {
                        x: Math.random() * gameCanvas.width,
                        y: -20,
                        speedX: Math.random() * 4 - 2,
                        speedY: 2 + Math.random() * 2,
                        size: 10 + Math.random() * 5,
                        lifetime: 300,
                        canShoot: Math.random() < 0.3,
                        nextShoot: 60 + Math.random() * 60
                    };
                    
                    stageBats.push(bat);
                }, i * 300);
            }
            break;
    }
}

// 检查关卡完成
function checkStageComplete() {
    if (bosses.length === 0 && enemies.length === 0 && GAME_STATE.stageTimer > 0) {
        const stage = STAGES[GAME_STATE.currentStage];
        
        // 如果有Boss且已生成，则等待Boss被击败
        if (stage && stage.boss) {
            const lastEnemyGroup = stage.enemies[stage.enemies.length - 1];
            const bossSpawnTime = (lastEnemyGroup.delay + 10) * 60;
            
            if (GAME_STATE.stageTimer > bossSpawnTime + 60) { // 等待额外1秒确保Boss已生成
                // Boss已被击败，关卡完成
                GAME_STATE.currentStage++;
                
                if (GAME_STATE.currentStage < STAGES.length) {
                    // 加载下一关
                    setTimeout(() => {
                        loadStage(GAME_STATE.currentStage);
                    }, 3000);
                } else {
                    // 通关
                    gameCompleted();
                }
            }
        }
    }
}

// 加载关卡
function loadStage(stageIndex) {
    if (stageIndex < 0 || stageIndex >= STAGES.length) return;
    
    // 重置关卡状态
    GAME_STATE.stageTimer = 0;
    
    // 清空所有实体
    enemies = [];
    bosses = [];
    enemyBullets = [];
    items = [];
    effects = [];
    stageEffects = [];
    stageObstacles = [];
    stageHazards = [];
    bossShadows = [];
    stageBats = [];
    stageFateCircles = [];
    
    // 重置玩家位置
    if (player) {
        player.x = gameCanvas.width / 2;
        player.y = gameCanvas.height - 100;
    }
    
    // 显示关卡名称
    showStageAnnouncement(STAGES[stageIndex].name);
}

// 显示关卡名称
function showStageAnnouncement(stageName) {
    const announcement = document.getElementById('stage-clear');
    announcement.textContent = stageName;
    announcement.style.opacity = 1;
    
    setTimeout(() => {
        announcement.style.opacity = 0;
    }, 3000);
}

// 显示关卡完成
function showStageClear() {
    const announcement = document.getElementById('stage-clear');
    announcement.textContent = "Stage Clear!";
    announcement.style.opacity = 1;
    
    setTimeout(() => {
        announcement.style.opacity = 0;
    }, 3000);
}

// 显示符卡宣言
function announceSpellcard(spellName) {
    const announcement = document.getElementById('spell-announcement');
    announcement.textContent = spellName;
    announcement.style.opacity = 1;
    
    setTimeout(() => {
        announcement.style.opacity = 0;
    }, 3000);
}

// 更新难度等级
function updateRank() {
    // 根据各种因素动态调整难度
    
    // 玩家性能
    const performanceFactor = (GAME_STATE.graze * 0.05) + (GAME_STATE.combo * 0.1) - (GAME_STATE.lives * 5);
    
    // 游戏进度
    const progressFactor = GAME_STATE.currentStage * 15 + (GAME_STATE.stageTimer / 3600) * 10;
    
    // 计算新难度
    const newRank = Math.max(0, Math.min(CONFIG.MAX_RANK, 
                                      performanceFactor + progressFactor));
    
    // 平滑过渡
    GAME_STATE.rank = GAME_STATE.rank * 0.95 + newRank * 0.05;
}

// 游戏结束
function gameOver() {
    GAME_STATE.isGameOver = true;
    GAME_STATE.isRunning = false;
    
    // 保存高分
    if (GAME_STATE.score > GAME_STATE.highScore) {
        GAME_STATE.highScore = GAME_STATE.score;
        localStorage.setItem('highScore', GAME_STATE.highScore);
    }
    
    // 保存成就和符卡历史
    localStorage.setItem('achievements', JSON.stringify(GAME_STATE.achievements));
    localStorage.setItem('spellHistory', JSON.stringify(GAME_STATE.spellHistory));
    
    // 显示游戏结束画面
    setTimeout(() => {
        showGameOver();
    }, 2000);
}

// 游戏通关
function gameCompleted() {
    GAME_STATE.isGameOver = true;
    GAME_STATE.isRunning = false;
    
    // 解锁成就
    checkAchievement("first_clear", 1);
    
    // 生命奖励
    const lifeBonus = GAME_STATE.lives * CONFIG.LIFE_BONUS;
    GAME_STATE.score += lifeBonus;
    
    // 保存高分
    if (GAME_STATE.score > GAME_STATE.highScore) {
        GAME_STATE.highScore = GAME_STATE.score;
        localStorage.setItem('highScore', GAME_STATE.highScore);
    }
    
    // 保存成就和符卡历史
    localStorage.setItem('achievements', JSON.stringify(GAME_STATE.achievements));
    localStorage.setItem('spellHistory', JSON.stringify(GAME_STATE.spellHistory));
    
    // 显示游戏通关画面
    setTimeout(() => {
        showGameCompleted();
    }, 3000);
}

// 暂停游戏
function togglePause() {
    GAME_STATE.isPaused = !GAME_STATE.isPaused;
    
    if (GAME_STATE.isPaused) {
        showPauseMenu();
    } else {
        hidePauseMenu();
    }
}

// 绘制游戏画面
function draw() {
    // 清空画布
    gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
    uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
    
    // 绘制游戏背景
    drawBackground();
    
    // 绘制舞台特效（底层）
    drawStageEffectsBackground();
    
    // 绘制游戏实体
    drawItems();
    drawEnemies();
    drawBosses();
    drawBullets();
    drawPlayer();
    drawEffects();
    
    // 绘制舞台特效（顶层）
    drawStageEffectsOverlay();
    
    // 绘制UI
    drawUI();
    
    // 暂停或游戏结束状态
    if (GAME_STATE.isPaused) {
        drawPause();
    } else if (GAME_STATE.isGameOver) {
        drawGameOver();
    }
}

// 绘制背景
function drawBackground() {
    // 获取当前关卡背景色
    let backgroundColor = "#000000";
    
    if (GAME_STATE.currentStage < STAGES.length) {
        backgroundColor = STAGES[GAME_STATE.currentStage].background;
    }
    
    // 渐变背景
    const gradient = gameCtx.createLinearGradient(0, 0, 0, gameCanvas.height);
    gradient.addColorStop(0, backgroundColor);
    gradient.addColorStop(1, "#000000");
    
    gameCtx.fillStyle = gradient;
    gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
    
    // 星星背景
    gameCtx.fillStyle = "#ffffff";
    
    // 使用当前时间为种子，使星星闪烁
    const time = GAME_STATE.stageTimer * 0.01;
    for (let i = 0; i < 100; i++) {
        const x = Math.sin(i * 567.53 + time) * gameCanvas.width * 0.5 + gameCanvas.width * 0.5;
        const y = Math.cos(i * 267.12 + time) * gameCanvas.height * 0.5 + gameCanvas.height * 0.5;
        const size = 0.5 + Math.sin(i + time) * 0.5;
        
        gameCtx.globalAlpha = 0.1 + Math.sin(i * 0.1 + time) * 0.1;
        gameCtx.fillRect(x, y, size, size);
    }
    
    gameCtx.globalAlpha = 1;
    
    // 游戏区域边界
    gameCtx.strokeStyle = "#333333";
    gameCtx.lineWidth = 2;
    gameCtx.strokeRect(
        CONFIG.BORDER_WIDTH - 1,
        CONFIG.BORDER_WIDTH - 1,
        gameCanvas.width - CONFIG.BORDER_WIDTH * 2 + 2,
        gameCanvas.height - CONFIG.BORDER_WIDTH * 2 + 2
    );
}

// 绘制舞台特效（底层）
function drawStageEffectsBackground() {
    stageEffects.forEach(effect => {
        gameCtx.save();
        
        switch(effect.type) {
            case "ice":
                // 冰面效果
                const iceGradient = gameCtx.createLinearGradient(0, gameCanvas.height / 2, 0, gameCanvas.height);
                iceGradient.addColorStop(0, `rgba(100, 200, 255, 0)`);
                iceGradient.addColorStop(1, `rgba(100, 200, 255, ${effect.alpha})`);
                
                gameCtx.fillStyle = iceGradient;
                gameCtx.fillRect(0, gameCanvas.height / 2, gameCanvas.width, gameCanvas.height / 2);
                break;
        }
        
        gameCtx.restore();
    });
    
    // 绘制障碍物
    stageObstacles.forEach(obstacle => {
        gameCtx.save();
        
        gameCtx.globalAlpha = obstacle.alpha;
        gameCtx.translate(obstacle.x, obstacle.y);
        gameCtx.rotate(obstacle.rotation);
        
        // 绘制冰块
        gameCtx.fillStyle = "rgba(150, 220, 255, 0.7)";
        gameCtx.fillRect(-obstacle.width / 2, -obstacle.height / 2, obstacle.width, obstacle.height);
        
        // 冰块边缘
        gameCtx.strokeStyle = "rgba(255, 255, 255, 0.9)";
        gameCtx.lineWidth = 2;
        gameCtx.strokeRect(-obstacle.width / 2, -obstacle.height / 2, obstacle.width, obstacle.height);
        
        gameCtx.restore();
    });
    
    // 绘制危险区域
    stageHazards.forEach(hazard => {
        gameCtx.save();
        
        gameCtx.globalAlpha = hazard.alpha;
        
        // 绘制减速区域
        const gradient = gameCtx.createRadialGradient(
            hazard.x, hazard.y, 0,
            hazard.x, hazard.y, hazard.radius
        );
        gradient.addColorStop(0, "rgba(0, 100, 255, 0.5)");
        gradient.addColorStop(0.7, "rgba(0, 100, 255, 0.2)");
        gradient.addColorStop(1, "rgba(0, 100, 255, 0)");
        
        gameCtx.fillStyle = gradient;
        gameCtx.beginPath();
        gameCtx.arc(hazard.x, hazard.y, hazard.radius, 0, Math.PI * 2);
        gameCtx.fill();
        
        // 中心图案
        gameCtx.fillStyle = "rgba(100, 200, 255, 0.8)";
        gameCtx.beginPath();
        gameCtx.arc(hazard.x, hazard.y, 10, 0, Math.PI * 2);
        gameCtx.fill();
        
        gameCtx.restore();
    });
    
    // 绘制命运圈
    stageFateCircles.forEach(circle => {
        gameCtx.save();
        
        // 绘制圆环
        gameCtx.strokeStyle = "#ff3300";
        gameCtx.lineWidth = 3;
        gameCtx.beginPath();
        gameCtx.arc(circle.centerX, circle.centerY, circle.radius, 0, Math.PI * 2);
        gameCtx.stroke();
        
        // 绘制子弹点
        gameCtx.fillStyle = "#ff5500";
        
        for (let i = 0; i < circle.bulletCount; i++) {
            const angle = circle.currentAngle + (i / circle.bulletCount) * Math.PI * 2;
            const x = circle.centerX + Math.cos(angle) * circle.radius;
            const y = circle.centerY + Math.sin(angle) * circle.radius;
            
            gameCtx.beginPath();
            gameCtx.arc(x, y, 5, 0, Math.PI * 2);
            gameCtx.fill();
        }
        
        gameCtx.restore();
    });
}

// 绘制舞台特效（顶层）
function drawStageEffectsOverlay() {
    // 绘制Boss分身
    bossShadows.forEach(shadow => {
        gameCtx.save();
        
        gameCtx.globalAlpha = shadow.alpha;
        
        // 绘制分身
        gameCtx.fillStyle = "#aa5588";
        gameCtx.beginPath();
        gameCtx.arc(shadow.x, shadow.y, shadow.width / 2, 0, Math.PI * 2);
        gameCtx.fill();
        
        gameCtx.restore();
    });
    
    // 绘制蝙蝠
    stageBats.forEach(bat => {
        gameCtx.save();
        
        // 绘制蝙蝠
        gameCtx.fillStyle = "#660000";
        
        // 蝙蝠身体
        gameCtx.beginPath();
        gameCtx.arc(bat.x, bat.y, bat.size, 0, Math.PI * 2);
        gameCtx.fill();
        
        // 蝙蝠翅膀
        const wingSpan = bat.size * 3;
        const wingHeight = bat.size * 1.5;
        const flapAmount = Math.sin(GAME_STATE.stageTimer * 0.2) * 0.3 + 0.7;
        
        gameCtx.fillStyle = "#990000";
        
        // 左翅膀
        gameCtx.beginPath();
        gameCtx.moveTo(bat.x, bat.y - bat.size * 0.5);
        gameCtx.quadraticCurveTo(
            bat.x - wingSpan * flapAmount, 
            bat.y - wingHeight * flapAmount,
            bat.x - wingSpan * flapAmount, 
            bat.y
        );
        gameCtx.quadraticCurveTo(
            bat.x - wingSpan * 0.8 * flapAmount, 
            bat.y + wingHeight * 0.5 * flapAmount,
            bat.x, 
            bat.y + bat.size * 0.5
        );
        gameCtx.fill();
        
        // 右翅膀
        gameCtx.beginPath();
        gameCtx.moveTo(bat.x, bat.y - bat.size * 0.5);
        gameCtx.quadraticCurveTo(
            bat.x + wingSpan * flapAmount, 
            bat.y - wingHeight * flapAmount,
            bat.x + wingSpan * flapAmount, 
            bat.y
        );
        gameCtx.quadraticCurveTo(
            bat.x + wingSpan * 0.8 * flapAmount, 
            bat.y + wingHeight * 0.5 * flapAmount,
            bat.x, 
            bat.y + bat.size * 0.5
        );
        gameCtx.fill();
        
        // 眼睛
        gameCtx.fillStyle = "#ffffff";
        gameCtx.beginPath();
        gameCtx.arc(bat.x - bat.size * 0.3, bat.y - bat.size * 0.2, bat.size * 0.2, 0, Math.PI * 2);
        gameCtx.arc(bat.x + bat.size * 0.3, bat.y - bat.size * 0.2, bat.size * 0.2, 0, Math.PI * 2);
        gameCtx.fill();
        
        // 瞳孔
        gameCtx.fillStyle = "#ff0000";
        gameCtx.beginPath();
        gameCtx.arc(bat.x - bat.size * 0.3, bat.y - bat.size * 0.2, bat.size * 0.1, 0, Math.PI * 2);
        gameCtx.arc(bat.x + bat.size * 0.3, bat.y - bat.size * 0.2, bat.size * 0.1, 0, Math.PI * 2);
        gameCtx.fill();
        
        gameCtx.restore();
    });
    
    stageEffects.forEach(effect => {
        gameCtx.save();
        
        switch(effect.type) {
            case "fog":
                // 迷雾效果
                gameCtx.fillStyle = `rgba(200, 200, 200, ${effect.alpha})`;
                gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                break;
                
            case "blizzard":
                // 暴风雪效果
                gameCtx.fillStyle = `rgba(220, 240, 255, ${effect.alpha})`;
                gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                
                // 雪花粒子
                gameCtx.fillStyle = "#ffffff";
                
                for (let i = 0; i < 100; i++) {
                    const x = (Math.sin(i * 100 + GAME_STATE.stageTimer * 0.1) * 0.5 + 0.5) * gameCanvas.width;
                    const y = ((i * 10 + GAME_STATE.stageTimer * 5) % gameCanvas.height);
                    const size = 1 + Math.random() * 3;
                    
                    gameCtx.globalAlpha = effect.alpha * (0.3 + Math.random() * 0.7);
                    gameCtx.fillRect(x, y, size, size);
                }
                break;
                
            case "wind":
                // 风效果
                const direction = effect.direction === "left" ? -1 : 1;
                
                // 风线条
                gameCtx.strokeStyle = `rgba(200, 200, 200, ${effect.alpha * 0.7})`;
                gameCtx.lineWidth = 1;
                
                for (let i = 0; i < 30; i++) {
                    const y = (i * 30 + GAME_STATE.stageTimer * 2) % gameCanvas.height;
                    const length = 20 + Math.random() * 50;
                    const x = ((Math.sin(i * 100) * 0.5 + 0.5) * gameCanvas.width + GAME_STATE.stageTimer * direction * 5) % gameCanvas.width;
                    
                    gameCtx.globalAlpha = effect.alpha * (0.3 + Math.random() * 0.7);
                    gameCtx.beginPath();
                    gameCtx.moveTo(x, y);
                    gameCtx.lineTo(x + length * direction, y);
                    gameCtx.stroke();
                }
                
                // 如果玩家存在，应用风力效果
                if (player && !player.isFocused) {
                    player.x += effect.force;
                    
                    // 确保玩家不会被吹出边界
                    player.x = Math.max(CONFIG.BORDER_WIDTH, Math.min(gameCanvas.width - CONFIG.BORDER_WIDTH, player.x));
                }
                break;
                
            case "darkness":
                // 黑暗效果
                
                // 创建视野圆形遮罩效果
                const radius = 150;
                const gradient = gameCtx.createRadialGradient(
                    player ? player.x : gameCanvas.width / 2,
                    player ? player.y : gameCanvas.height / 2,
                    0,
                    player ? player.x : gameCanvas.width / 2,
                    player ? player.y : gameCanvas.height / 2,
                    radius
                );
                
                gradient.addColorStop(0, `rgba(0, 0, 0, 0)`);
                gradient.addColorStop(0.7, `rgba(0, 0, 0, ${effect.alpha * 0.3})`);
                gradient.addColorStop(1, `rgba(0, 0, 0, ${effect.alpha})`);
                
                gameCtx.fillStyle = `rgba(0, 0, 0, ${effect.alpha})`;
                gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                
                // 清除视野区域
                gameCtx.globalCompositeOperation = 'destination-out';
                gameCtx.fillStyle = gradient;
                gameCtx.beginPath();
                gameCtx.arc(
                    player ? player.x : gameCanvas.width / 2,
                    player ? player.y : gameCanvas.height / 2,
                    radius, 0, Math.PI * 2
                );
                gameCtx.fill();
                gameCtx.globalCompositeOperation = 'source-over';
                break;
                
            case "redMist":
                // 红雾效果
                gameCtx.fillStyle = `rgba(255, 100, 100, ${effect.alpha})`;
                gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                
                // 血液微粒
                gameCtx.fillStyle = "#ff0000";
                
                for (let i = 0; i < 50; i++) {
                    const x = (Math.sin(i * 123 + GAME_STATE.stageTimer * 0.05) * 0.5 + 0.5) * gameCanvas.width;
                    const y = ((i * 15 + GAME_STATE.stageTimer * 2) % gameCanvas.height);
                    const size = 2 + Math.random() * 4;
                    
                    gameCtx.globalAlpha = effect.alpha * (0.3 + Math.random() * 0.7);
                    gameCtx.beginPath();
                    gameCtx.arc(x, y, size, 0, Math.PI * 2);
                    gameCtx.fill();
                }
                break;
        }
        
        gameCtx.restore();
    });
}

// 绘制玩家
function drawPlayer() {
    if (player) {
        player.draw();
    }
}

// 绘制子弹
function drawBullets() {
    // 绘制敌人子弹
    enemyBullets.forEach(bullet => {
        bullet.draw();
    });
    
    // 绘制玩家子弹
    playerBullets.forEach(bullet => {
        bullet.draw();
    });
}

// 绘制敌人
function drawEnemies() {
    enemies.forEach(enemy => {
        enemy.draw();
    });
}

// 绘制Boss
function drawBosses() {
    bosses.forEach(boss => {
        boss.draw();
    });
}

// 绘制物品
function drawItems() {
    items.forEach(item => {
        item.draw();
    });
}

// 绘制效果
function drawEffects() {
    effects.forEach(effect => {
        effect.draw();
    });
}

// 绘制UI
function drawUI() {
    // 分数
    uiCtx.fillStyle = "#ffffff";
    uiCtx.font = "16px Arial";
    uiCtx.textAlign = "left";
    uiCtx.fillText(`分数: ${GAME_STATE.score.toLocaleString()}`, 10, 20);
    
    // 高分
    uiCtx.fillStyle = "#aaaaaa";
    uiCtx.fillText(`最高分: ${GAME_STATE.highScore.toLocaleString()}`, 10, 40);
    
    // 生命
    uiCtx.fillStyle = "#ff0000";
    uiCtx.fillText(`生命: ${GAME_STATE.lives}`, 10, 60);
    
    // 炸弹
    uiCtx.fillStyle = "#ff00ff";
    uiCtx.fillText(`炸弹: ${GAME_STATE.bombs}`, 10, 80);
    
    // 火力
    uiCtx.fillStyle = "#ffaa00";
    uiCtx.fillText(`火力: ${GAME_STATE.power.toFixed(2)}`, 10, 100);
    
    // 擦弹
    uiCtx.fillStyle = "#00ffff";
    uiCtx.fillText(`擦弹: ${GAME_STATE.graze}`, 10, 120);
    
    // 连击
    if (GAME_STATE.combo > 0) {
        uiCtx.fillStyle = GAME_STATE.combo > 50 ? "#ff0000" : 
                           GAME_STATE.combo > 20 ? "#ffff00" : "#ffffff";
        uiCtx.font = GAME_STATE.combo > 50 ? "bold 18px Arial" : "16px Arial";
        uiCtx.fillText(`连击: ${GAME_STATE.combo}`, 10, 140);
    }
    
    // 特殊资源
    if (player) {
        const resourceY = 170;
        const resourceHeight = 10;
        const resourceWidth = 100;
        
        // 根据角色显示不同的特殊资源
        switch(player.character) {
            case 0: // 灵梦 - 灵力
                uiCtx.fillStyle = "#ff8800";
                uiCtx.fillText(`灵力: ${GAME_STATE.resources.spirit}`, 10, resourceY - 10);
                
                // 灵力条
                uiCtx.fillStyle = "#333333";
                uiCtx.fillRect(10, resourceY, resourceWidth, resourceHeight);
                
                uiCtx.fillStyle = "#ff8800";
                uiCtx.fillRect(10, resourceY, resourceWidth * (player.uniqueMechanicValue / 100), resourceHeight);
                break;
                
            case 1: // 魔理沙 - 魔力
                uiCtx.fillStyle = "#8800ff";
                uiCtx.fillText(`魔力: ${GAME_STATE.resources.magic}`, 10, resourceY - 10);
                
                // 魔导书充能条
                uiCtx.fillStyle = "#333333";
                uiCtx.fillRect(10, resourceY, resourceWidth, resourceHeight);
                
                uiCtx.fillStyle = player.uniqueMechanicValue > 50 ? "#ffff00" : "#8800ff";
                uiCtx.fillRect(10, resourceY, resourceWidth * (player.uniqueMechanicValue / 100), resourceHeight);
                break;
                
            case 2: // 咲夜 - 信仰
                uiCtx.fillStyle = "#00ffff";
                uiCtx.fillText(`信仰: ${GAME_STATE.resources.faith}`, 10, resourceY - 10);
                
                // 时钟装置条
                uiCtx.fillStyle = "#333333";
                uiCtx.fillRect(10, resourceY, resourceWidth, resourceHeight);
                
                uiCtx.fillStyle = player.uniqueMechanicActive ? "#00ffff" : "#aaaaff";
                uiCtx.fillRect(10, resourceY, resourceWidth * (player.uniqueMechanicValue / 100), resourceHeight);
                break;
        }
        
        // 完美回避计数器
        if (player.perfectDodgeCounter > 0) {
            const dodgePercent = player.perfectDodgeCounter / 30;
            
            uiCtx.fillStyle = "#333333";
            uiCtx.fillRect(10, resourceY + 20, resourceWidth, resourceHeight);
            
            uiCtx.fillStyle = dodgePercent > 0.8 ? "#00ff00" : "#88ffff";
            uiCtx.fillRect(10, resourceY + 20, resourceWidth * dodgePercent, resourceHeight);
            
            uiCtx.fillStyle = "#ffffff";
            uiCtx.fillText("回避", 10, resourceY + 45);
        }
    }
    
    // 右侧信息
    uiCtx.textAlign = "right";
    
    // 当前关卡
    uiCtx.fillStyle = "#ffffff";
    uiCtx.fillText(`关卡: ${GAME_STATE.currentStage + 1}`, gameCanvas.width - 10, 20);
    
    // 难度等级
    const rankColor = GAME_STATE.rank < 33 ? "#00ff00" : 
                      GAME_STATE.rank < 66 ? "#ffff00" : "#ff0000";
    uiCtx.fillStyle = rankColor;
    uiCtx.fillText(`难度: ${Math.floor(GAME_STATE.rank)}`, gameCanvas.width - 10, 40);
    
    // 点数值
    uiCtx.fillStyle = "#ffff00";
    uiCtx.fillText(`点数: ${GAME_STATE.pointValue * 100}`, gameCanvas.width - 10, 60);
    
    // 帧率信息（仅调试用）
    // uiCtx.fillStyle = "#aaaaaa";
    // uiCtx.fillText(`FPS: ${Math.round(1000 / deltaTime)}`, gameCanvas.width - 10, 80);
}

// 绘制暂停画面
function drawPause() {
    gameCtx.fillStyle = "rgba(0, 0, 0, 0.7)";
    gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
    
    gameCtx.fillStyle = "#ffffff";
    gameCtx.font = "24px Arial";
    gameCtx.textAlign = "center";
    gameCtx.fillText("游戏暂停", gameCanvas.width / 2, gameCanvas.height / 2 - 20);
    
    gameCtx.font = "16px Arial";
    gameCtx.fillText("按 ESC 继续游戏", gameCanvas.width / 2, gameCanvas.height / 2 + 20);
}

// 绘制游戏结束画面
function drawGameOver() {
    gameCtx.fillStyle = "rgba(0, 0, 0, 0.7)";
    gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
    
    gameCtx.fillStyle = "#ff0000";
    gameCtx.font = "36px Arial";
    gameCtx.textAlign = "center";
    gameCtx.fillText("游戏结束", gameCanvas.width / 2, gameCanvas.height / 2 - 50);
    
    gameCtx.fillStyle = "#ffffff";
    gameCtx.font = "24px Arial";
    gameCtx.fillText(`最终得分: ${GAME_STATE.score.toLocaleString()}`, gameCanvas.width / 2, gameCanvas.height / 2);
    
    gameCtx.font = "18px Arial";
    gameCtx.fillText(`最大连击: ${GAME_STATE.maxCombo}`, gameCanvas.width / 2, gameCanvas.height / 2 + 30);
    gameCtx.fillText(`擦弹总数: ${GAME_STATE.graze}`, gameCanvas.width / 2, gameCanvas.height / 2 + 60);
    
    gameCtx.font = "16px Arial";
    gameCtx.fillText("点击任意位置返回菜单", gameCanvas.width / 2, gameCanvas.height / 2 + 100);
}

// 显示游戏结束菜单
function showGameOver() {
    menu.style.display = "flex";
    
    // 添加点击事件，点击任意位置返回菜单
    gameCanvas.addEventListener('click', goBackToMenu, { once: true });
}

// 显示游戏通关菜单
function showGameCompleted() {
    // 自定义通关界面
    const completedMenu = document.createElement('div');
    completedMenu.style.position = "absolute";
    completedMenu.style.width = "100%";
    completedMenu.style.height = "100%";
    completedMenu.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
    completedMenu.style.display = "flex";
    completedMenu.style.flexDirection = "column";
    completedMenu.style.justifyContent = "center";
    completedMenu.style.alignItems = "center";
    completedMenu.style.zIndex = "20";
    
    // 标题
    const title = document.createElement('div');
    title.style.fontSize = "48px";
    title.style.color = "#ffff00";
    title.style.marginBottom = "40px";
    title.style.textShadow = "0 0 15px #ff0, 0 0 30px #ff0";
    title.textContent = "恭喜通关！";
    completedMenu.appendChild(title);
    
    // 分数
    const score = document.createElement('div');
    score.style.fontSize = "28px";
    score.style.color = "#ffffff";
    score.style.marginBottom = "20px";
    score.textContent = `最终得分: ${GAME_STATE.score.toLocaleString()}`;
    completedMenu.appendChild(score);
    
    // 统计
    const stats = document.createElement('div');
    stats.style.fontSize = "20px";
    stats.style.color = "#aaaaaa";
    stats.style.marginBottom = "40px";
    stats.style.textAlign = "center";
    stats.innerHTML = `最大连击: ${GAME_STATE.maxCombo}<br>
                      擦弹总数: ${GAME_STATE.graze}<br>
                      剩余生命: ${GAME_STATE.lives}<br>
                      游戏难度: ${Math.floor(GAME_STATE.rank)}/100`;
    completedMenu.appendChild(stats);
    
    // 返回按钮
    const backButton = document.createElement('div');
    backButton.style.fontSize = "24px";
    backButton.style.padding = "10px 20px";
    backButton.style.backgroundColor = "#222";
    backButton.style.border = "1px solid #666";
    backButton.style.cursor = "pointer";
    backButton.style.transition = "all 0.3s";
    backButton.textContent = "返回主菜单";
    
    backButton.addEventListener('mouseover', () => {
        backButton.style.backgroundColor = "#444";
        backButton.style.transform = "scale(1.1)";
        backButton.style.boxShadow = "0 0 15px #88f";
    });
    
    backButton.addEventListener('mouseout', () => {
        backButton.style.backgroundColor = "#222";
        backButton.style.transform = "scale(1)";
        backButton.style.boxShadow = "none";
    });
    
    backButton.addEventListener('click', () => {
        completedMenu.remove();
        goBackToMenu();
    });
    
    completedMenu.appendChild(backButton);
    
    document.getElementById('game-container').appendChild(completedMenu);
}

// 返回主菜单
function goBackToMenu() {
    GAME_STATE.isRunning = false;
    GAME_STATE.isPaused = false;
    GAME_STATE.isGameOver = false;
    
    menu.style.display = "flex";
    
    // 停止游戏循环
    if (gameLoopInterval) {
        clearInterval(gameLoopInterval);
        gameLoopInterval = null;
    }
}

// 显示暂停菜单
function showPauseMenu() {
    // 可以实现更复杂的暂停菜单
}

// 隐藏暂停菜单
function hidePauseMenu() {
    // 与showPauseMenu对应
}

// 显示角色选择菜单
function showCharacterSelect() {
    // 隐藏主菜单
    menu.style.display = "none";
    
    // 创建角色选择菜单
    const characterSelectMenu = document.createElement('div');
    characterSelectMenu.style.position = "absolute";
    characterSelectMenu.style.width = "100%";
    characterSelectMenu.style.height = "100%";
    characterSelectMenu.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
    characterSelectMenu.style.display = "flex";
    characterSelectMenu.style.flexDirection = "column";
    characterSelectMenu.style.justifyContent = "center";
    characterSelectMenu.style.alignItems = "center";
    characterSelectMenu.style.zIndex = "20";
    
    // 标题
    const title = document.createElement('div');
    title.style.fontSize = "36px";
    title.style.color = "#ffffff";
    title.style.marginBottom = "40px";
    title.textContent = "选择角色";
    characterSelectMenu.appendChild(title);
    
    // 角色列表
    const characterList = document.createElement('div');
    characterList.style.display = "flex";
    characterList.style.justifyContent = "center";
    characterList.style.gap = "30px";
    characterList.style.marginBottom = "40px";
    
    CHARACTERS.forEach((character, index) => {
        // 角色卡片
        const characterCard = document.createElement('div');
        characterCard.style.width = "140px";
        characterCard.style.padding = "20px";
        characterCard.style.backgroundColor = "#222";
        characterCard.style.border = "1px solid #666";
        characterCard.style.borderRadius = "10px";
        characterCard.style.textAlign = "center";
        characterCard.style.cursor = "pointer";
        characterCard.style.transition = "all 0.3s";
        
        // 角色名称
        const characterName = document.createElement('div');
        characterName.style.fontSize = "24px";
        characterName.style.color = character.color;
        characterName.style.marginBottom = "15px";
        characterName.textContent = character.name;
        characterCard.appendChild(characterName);
        
        // 角色图标
        const characterIcon = document.createElement('div');
        characterIcon.style.width = "80px";
        characterIcon.style.height = "80px";
        characterIcon.style.borderRadius = "50%";
        characterIcon.style.backgroundColor = character.color;
        characterIcon.style.margin = "0 auto 15px";
        characterCard.appendChild(characterIcon);
        
        // 角色属性
        const characterStats = document.createElement('div');
        characterStats.style.fontSize = "14px";
        characterStats.style.color = "#aaaaaa";
        characterStats.style.marginBottom = "15px";
        characterStats.innerHTML = `火力类型: ${character.shotType}<br>
                                  速度: ${character.speed}<br>
                                  特殊能力: ${character.special}`;
        characterCard.appendChild(characterStats);
        
        // 选择事件
        characterCard.addEventListener('mouseover', () => {
            characterCard.style.backgroundColor = "#444";
            characterCard.style.transform = "scale(1.1)";
            characterCard.style.boxShadow = `0 0 15px ${character.color}`;
        });
        
        characterCard.addEventListener('mouseout', () => {
            characterCard.style.backgroundColor = "#222";
            characterCard.style.transform = "scale(1)";
            characterCard.style.boxShadow = "none";
        });
        
        characterCard.addEventListener('click', () => {
            GAME_STATE.selectedCharacter = index;
            characterSelectMenu.remove();
            menu.style.display = "flex";
        });
        
        characterList.appendChild(characterCard);
    });
    
    characterSelectMenu.appendChild(characterList);
    
    // 返回按钮
    const backButton = document.createElement('div');
    backButton.style.fontSize = "18px";
    backButton.style.padding = "10px 20px";
    backButton.style.backgroundColor = "#222";
    backButton.style.border = "1px solid #666";
    backButton.style.cursor = "pointer";
    backButton.style.transition = "all 0.3s";
    backButton.textContent = "返回主菜单";
    
    backButton.addEventListener('mouseover', () => {
        backButton.style.backgroundColor = "#444";
        backButton.style.transform = "scale(1.1)";
        backButton.style.boxShadow = "0 0 15px #88f";
    });
    
    backButton.addEventListener('mouseout', () => {
        backButton.style.backgroundColor = "#222";
        backButton.style.transform = "scale(1)";
        backButton.style.boxShadow = "none";
    });
    
    backButton.addEventListener('click', () => {
        characterSelectMenu.remove();
        menu.style.display = "flex";
    });
    
    characterSelectMenu.appendChild(backButton);
    
    document.getElementById('game-container').appendChild(characterSelectMenu);
}

// 显示关卡选择菜单
function showStageSelect() {
    // 隐藏主菜单
    menu.style.display = "none";
    
    // 创建关卡选择菜单
    const stageSelectMenu = document.createElement('div');
    stageSelectMenu.style.position = "absolute";
    stageSelectMenu.style.width = "100%";
    stageSelectMenu.style.height = "100%";
    stageSelectMenu.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
    stageSelectMenu.style.display = "flex";
    stageSelectMenu.style.flexDirection = "column";
    stageSelectMenu.style.justifyContent = "center";
    stageSelectMenu.style.alignItems = "center";
    stageSelectMenu.style.zIndex = "20";
    
    // 标题
    const title = document.createElement('div');
    title.style.fontSize = "36px";
    title.style.color = "#ffffff";
    title.style.marginBottom = "40px";
    title.textContent = "选择关卡";
    stageSelectMenu.appendChild(title);
    
    // 关卡列表
    const stageList = document.createElement('div');
    stageList.style.display = "flex";
    stageList.style.flexDirection = "column";
    stageList.style.gap = "20px";
    stageList.style.marginBottom = "40px";
    
    STAGES.forEach((stage, index) => {
        // 关卡按钮
        const stageButton = document.createElement('div');
        stageButton.style.padding = "15px 30px";
        stageButton.style.backgroundColor = stage.background;
        stageButton.style.border = "1px solid #666";
        stageButton.style.borderRadius = "10px";
        stageButton.style.cursor = "pointer";
        stageButton.style.transition = "all 0.3s";
        stageButton.style.width = "300px";
        stageButton.style.textAlign = "center";
        
        // 关卡名称
        const stageName = document.createElement('div');
        stageName.style.fontSize = "20px";
        stageName.style.color = "#ffffff";
        stageName.textContent = stage.name;
        stageButton.appendChild(stageName);
        
        // Boss信息
        const bossInfo = document.createElement('div');
        bossInfo.style.fontSize = "16px";
        bossInfo.style.color = "#aaaaaa";
        bossInfo.style.marginTop = "10px";
        bossInfo.textContent = `Boss: ${stage.boss.name} - ${stage.boss.title}`;
        stageButton.appendChild(bossInfo);
        
        // 选择事件
        stageButton.addEventListener('mouseover', () => {
            stageButton.style.transform = "scale(1.05)";
            stageButton.style.boxShadow = "0 0 15px #fff";
        });
        
        stageButton.addEventListener('mouseout', () => {
            stageButton.style.transform = "scale(1)";
            stageButton.style.boxShadow = "none";
        });
        
        stageButton.addEventListener('click', () => {
            GAME_STATE.currentStage = index;
            stageSelectMenu.remove();
            loadStage(index);
        });
        
        stageList.appendChild(stageButton);
    });
    
    stageSelectMenu.appendChild(stageList);
    
    // 返回按钮
    const backButton = document.createElement('div');
    backButton.style.fontSize = "18px";
    backButton.style.padding = "10px 20px";
    backButton.style.backgroundColor = "#222";
    backButton.style.border = "1px solid #666";
    backButton.style.cursor = "pointer";
    backButton.style.transition = "all 0.3s";
    backButton.textContent = "返回主菜单";
    
    backButton.addEventListener('mouseover', () => {
        backButton.style.backgroundColor = "#444";
        backButton.style.transform = "scale(1.1)";
        backButton.style.boxShadow = "0 0 15px #88f";
    });
    
    backButton.addEventListener('mouseout', () => {
        backButton.style.backgroundColor = "#222";
        backButton.style.transform = "scale(1)";
        backButton.style.boxShadow = "none";
    });
    
    backButton.addEventListener('click', () => {
        stageSelectMenu.remove();
        menu.style.display = "flex";
        GAME_STATE.isRunning = false;
    });
    
    stageSelectMenu.appendChild(backButton);
    
    document.getElementById('game-container').appendChild(stageSelectMenu);
}

// 显示符卡练习菜单
function showSpellPractice() {
    // 隐藏主菜单
    menu.style.display = "none";
    
    // 创建符卡练习菜单
    const spellPracticeMenu = document.createElement('div');
    spellPracticeMenu.style.position = "absolute";
    spellPracticeMenu.style.width = "100%";
    spellPracticeMenu.style.height = "100%";
    spellPracticeMenu.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
    spellPracticeMenu.style.display = "flex";
    spellPracticeMenu.style.flexDirection = "column";
    spellPracticeMenu.style.justifyContent = "center";
    spellPracticeMenu.style.alignItems = "center";
    spellPracticeMenu.style.zIndex = "20";
    
    // 标题
    const title = document.createElement('div');
    title.style.fontSize = "36px";
    title.style.color = "#ffffff";
    title.style.marginBottom = "30px";
    title.textContent = "符卡练习";
    spellPracticeMenu.appendChild(title);
    
    // 符卡列表容器（可滚动）
    const spellListContainer = document.createElement('div');
    spellListContainer.style.width = "80%";
    spellListContainer.style.maxHeight = "400px";
    spellListContainer.style.overflowY = "auto";
    spellListContainer.style.marginBottom = "30px";
    
    // 符卡列表
    const spellList = document.createElement('div');
    spellList.style.display = "flex";
    spellList.style.flexDirection = "column";
    spellList.style.gap = "15px";
    spellListContainer.appendChild(spellList);
    
    // 按Boss分组
    const bosses = {};
    
    SPELLCARDS.forEach(spell => {
        if (!bosses[spell.boss]) {
            bosses[spell.boss] = [];
        }
        bosses[spell.boss].push(spell);
    });
    
    // 创建每个Boss的符卡列表
    Object.keys(bosses).forEach(bossName => {
        // Boss标题
        const bossTitle = document.createElement('div');
        bossTitle.style.fontSize = "24px";
        bossTitle.style.color = "#ffff88";
        bossTitle.style.marginTop = "20px";
        bossTitle.style.marginBottom = "10px";
        bossTitle.style.borderBottom = "1px solid #ffff88";
        bossTitle.style.paddingBottom = "5px";
        bossTitle.textContent = bossName;
        spellList.appendChild(bossTitle);
        
        // 该Boss的符卡
        bosses[bossName].forEach(spell => {
            // 符卡按钮
            const spellButton = document.createElement('div');
            spellButton.style.padding = "12px 20px";
            spellButton.style.backgroundColor = "#333";
            spellButton.style.border = "1px solid #666";
            spellButton.style.borderRadius = "5px";
            spellButton.style.cursor = "pointer";
            spellButton.style.transition = "all 0.3s";
            spellButton.style.display = "flex";
            spellButton.style.justifyContent = "space-between";
            spellButton.style.alignItems = "center";
            
            // 左侧：符卡名称
            const spellName = document.createElement('div');
            spellName.style.fontSize = "18px";
            spellName.style.color = "#ffffff";
            spellName.textContent = spell.name;
            spellButton.appendChild(spellName);
            
            // 右侧：符卡记录
            const spellHistory = document.createElement('div');
            spellHistory.style.fontSize = "14px";
            spellHistory.style.color = "#aaaaaa";
            
            // 检查历史记录
            const spellId = `${spell.boss}_${spell.name}`;
            const history = GAME_STATE.spellHistory[spellId] || { attempts: 0, captures: 0 };
            
            spellHistory.textContent = `${history.captures}/${history.attempts || 0}`;
            spellButton.appendChild(spellHistory);
            
            // 选择事件
            spellButton.addEventListener('mouseover', () => {
                spellButton.style.backgroundColor = "#555";
                spellButton.style.transform = "scale(1.03)";
                spellButton.style.boxShadow = "0 0 10px #ff00ff";
            });
            
            spellButton.addEventListener('mouseout', () => {
                spellButton.style.backgroundColor = "#333";
                spellButton.style.transform = "scale(1)";
                spellButton.style.boxShadow = "none";
            });
            
            spellButton.addEventListener('click', () => {
                GAME_STATE.practiceSpell = spell;
                spellPracticeMenu.remove();
                startSpellPractice();
            });
            
            spellList.appendChild(spellButton);
        });
    });
    
    spellPracticeMenu.appendChild(spellListContainer);
    
    // 返回按钮
    const backButton = document.createElement('div');
    backButton.style.fontSize = "18px";
    backButton.style.padding = "10px 20px";
    backButton.style.backgroundColor = "#222";
    backButton.style.border = "1px solid #666";
    backButton.style.cursor = "pointer";
    backButton.style.transition = "all 0.3s";
    backButton.textContent = "返回主菜单";
    
    backButton.addEventListener('mouseover', () => {
        backButton.style.backgroundColor = "#444";
        backButton.style.transform = "scale(1.1)";
        backButton.style.boxShadow = "0 0 15px #88f";
    });
    
    backButton.addEventListener('mouseout', () => {
        backButton.style.backgroundColor = "#222";
        backButton.style.transform = "scale(1)";
        backButton.style.boxShadow = "none";
    });
    
    backButton.addEventListener('click', () => {
        spellPracticeMenu.remove();
        menu.style.display = "flex";
    });
    
    spellPracticeMenu.appendChild(backButton);
    
    document.getElementById('game-container').appendChild(spellPracticeMenu);
}

// 显示成就菜单
function showAchievements() {
    // 隐藏主菜单
    menu.style.display = "none";
    
    // 创建成就菜单
    const achievementsMenu = document.createElement('div');
    achievementsMenu.style.position = "absolute";
    achievementsMenu.style.width = "100%";
    achievementsMenu.style.height = "100%";
    achievementsMenu.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
    achievementsMenu.style.display = "flex";
    achievementsMenu.style.flexDirection = "column";
    achievementsMenu.style.justifyContent = "center";
    achievementsMenu.style.alignItems = "center";
    achievementsMenu.style.zIndex = "20";
    
    // 标题
    const title = document.createElement('div');
    title.style.fontSize = "36px";
    title.style.color = "#ffffff";
    title.style.marginBottom = "30px";
    title.textContent = "成就系统";
    achievementsMenu.appendChild(title);
    
    // 成就列表容器（可滚动）
    const achievementsContainer = document.createElement('div');
    achievementsContainer.style.width = "80%";
    achievementsContainer.style.maxHeight = "400px";
    achievementsContainer.style.overflowY = "auto";
    achievementsContainer.style.marginBottom = "30px";
    
    // 成就列表
    const achievementsList = document.createElement('div');
    achievementsList.style.display = "grid";
    achievementsList.style.gridTemplateColumns = "repeat(2, 1fr)";
    achievementsList.style.gap = "15px";
    achievementsContainer.appendChild(achievementsList);
    
    // 添加成就
    ACHIEVEMENTS.forEach(achievement => {
        const achievementBox = document.createElement('div');
        const isUnlocked = GAME_STATE.achievements[achievement.id]?.unlocked;
        
        achievementBox.style.padding = "15px";
        achievementBox.style.backgroundColor = isUnlocked ? "#335533" : "#333";
        achievementBox.style.border = `1px solid ${isUnlocked ? "#88ff88" : "#666"}`;
        achievementBox.style.borderRadius = "5px";
        achievementBox.style.transition = "all 0.3s";
        
        // 成就图标和状态
        const achievementHeader = document.createElement('div');
        achievementHeader.style.display = "flex";
        achievementHeader.style.justifyContent = "space-between";
        achievementHeader.style.alignItems = "center";
        achievementHeader.style.marginBottom = "10px";
        
        // 成就名称
        const achievementName = document.createElement('div');
        achievementName.style.fontSize = "18px";
        achievementName.style.color = isUnlocked ? "#88ff88" : "#ffffff";
        achievementName.style.fontWeight = isUnlocked ? "bold" : "normal";
        achievementName.textContent = achievement.name;
        achievementHeader.appendChild(achievementName);
        
        // 解锁状态
        const achievementStatus = document.createElement('div');
        achievementStatus.style.fontSize = "14px";
        achievementStatus.style.padding = "3px 8px";
        achievementStatus.style.borderRadius = "3px";
        achievementStatus.style.backgroundColor = isUnlocked ? "#00aa00" : "#aaaaaa";
        achievementStatus.style.color = "#ffffff";
        achievementStatus.textContent = isUnlocked ? "已解锁" : "未解锁";
        achievementHeader.appendChild(achievementStatus);
        
        achievementBox.appendChild(achievementHeader);
        
        // 成就描述
        const achievementDesc = document.createElement('div');
        achievementDesc.style.fontSize = "14px";
        achievementDesc.style.color = "#aaaaaa";
        achievementDesc.textContent = achievement.description;
        achievementBox.appendChild(achievementDesc);
        
        // 如果已解锁，显示解锁日期
        if (isUnlocked && GAME_STATE.achievements[achievement.id].date) {
            const unlockDate = new Date(GAME_STATE.achievements[achievement.id].date);
            const achievementDate = document.createElement('div');
            achievementDate.style.fontSize = "12px";
            achievementDate.style.color = "#88ff88";
            achievementDate.style.marginTop = "10px";
            achievementDate.style.textAlign = "right";
            achievementDate.textContent = `解锁于: ${unlockDate.toLocaleDateString()}`;
            achievementBox.appendChild(achievementDate);
        }
        
        // 如果未解锁，显示进度
        if (!isUnlocked && GAME_STATE.achievements[achievement.id]?.progress > 0) {
            const progressContainer = document.createElement('div');
            progressContainer.style.marginTop = "10px";
            
            const progressBar = document.createElement('div');
            progressBar.style.width = "100%";
            progressBar.style.height = "5px";
            progressBar.style.backgroundColor = "#333";
            progressBar.style.borderRadius = "3px";
            progressBar.style.overflow = "hidden";
            
            const progress = document.createElement('div');
            const progressPercent = Math.min(100, GAME_STATE.achievements[achievement.id].progress * 100);
            progress.style.width = `${progressPercent}%`;
            progress.style.height = "100%";
            progress.style.backgroundColor = "#88f";
            
            progressBar.appendChild(progress);
            progressContainer.appendChild(progressBar);
            
            const progressText = document.createElement('div');
            progressText.style.fontSize = "12px";
            progressText.style.color = "#aaaaaa";
            progressText.style.marginTop = "5px";
            progressText.style.textAlign = "right";
            progressText.textContent = `进度: ${progressPercent.toFixed(0)}%`;
            progressContainer.appendChild(progressText);
            
            achievementBox.appendChild(progressContainer);
        }
        
        achievementsList.appendChild(achievementBox);
    });
    
    achievementsMenu.appendChild(achievementsContainer);
    
    // 返回按钮
    const backButton = document.createElement('div');
    backButton.style.fontSize = "18px";
    backButton.style.padding = "10px 20px";
    backButton.style.backgroundColor = "#222";
    backButton.style.border = "1px solid #666";
    backButton.style.cursor = "pointer";
    backButton.style.transition = "all 0.3s";
    backButton.textContent = "返回主菜单";
    
    backButton.addEventListener('mouseover', () => {
        backButton.style.backgroundColor = "#444";
        backButton.style.transform = "scale(1.1)";
        backButton.style.boxShadow = "0 0 15px #88f";
    });
    
    backButton.addEventListener('mouseout', () => {
        backButton.style.backgroundColor = "#222";
        backButton.style.transform = "scale(1)";
        backButton.style.boxShadow = "none";
    });
    
    backButton.addEventListener('click', () => {
        achievementsMenu.remove();
        menu.style.display = "flex";
    });
    
    achievementsMenu.appendChild(backButton);
    
    document.getElementById('game-container').appendChild(achievementsMenu);
}

// 显示选项菜单
function showOptions() {
    // 隐藏主菜单
    menu.style.display = "none";
    
    // 创建选项菜单
    const optionsMenu = document.createElement('div');
    optionsMenu.style.position = "absolute";
    optionsMenu.style.width = "100%";
    optionsMenu.style.height = "100%";
    optionsMenu.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
    optionsMenu.style.display = "flex";
    optionsMenu.style.flexDirection = "column";
    optionsMenu.style.justifyContent = "center";
    optionsMenu.style.alignItems = "center";
    optionsMenu.style.zIndex = "20";
    
    // 标题
    const title = document.createElement('div');
    title.style.fontSize = "36px";
    title.style.color = "#ffffff";
    title.style.marginBottom = "40px";
    title.textContent = "游戏选项";
    optionsMenu.appendChild(title);
    
    // 选项列表
    const optionsList = document.createElement('div');
    optionsList.style.display = "flex";
    optionsList.style.flexDirection = "column";
    optionsList.style.gap = "20px";
    optionsList.style.width = "60%";
    optionsList.style.marginBottom = "40px";
    
    // 难度选项
    const difficultyOption = document.createElement('div');
    difficultyOption.style.display = "flex";
    difficultyOption.style.justifyContent = "space-between";
    difficultyOption.style.alignItems = "center";
    
    const difficultyLabel = document.createElement('div');
    difficultyLabel.style.fontSize = "20px";
    difficultyLabel.style.color = "#ffffff";
    difficultyLabel.textContent = "游戏难度";
    difficultyOption.appendChild(difficultyLabel);
    
    const difficultySelect = document.createElement('select');
    difficultySelect.style.padding = "8px 15px";
    difficultySelect.style.backgroundColor = "#333";
    difficultySelect.style.color = "#ffffff";
    difficultySelect.style.border = "1px solid #666";
    difficultySelect.style.borderRadius = "5px";
    difficultySelect.style.cursor = "pointer";
    
    ["Easy", "Normal", "Hard", "Lunatic"].forEach(difficulty => {
        const option = document.createElement('option');
        option.value = difficulty;
        option.textContent = difficulty;
        option.selected = difficulty === GAME_STATE.difficulty;
        difficultySelect.appendChild(option);
    });
    
    difficultySelect.addEventListener('change', () => {
        GAME_STATE.difficulty = difficultySelect.value;
    });
    
    difficultyOption.appendChild(difficultySelect);
    optionsList.appendChild(difficultyOption);
    
    // 清除游戏数据选项
    const clearDataOption = document.createElement('div');
    clearDataOption.style.display = "flex";
    clearDataOption.style.justifyContent = "space-between";
    clearDataOption.style.alignItems = "center";
    clearDataOption.style.marginTop = "20px";
    
    const clearDataLabel = document.createElement('div');
    clearDataLabel.style.fontSize = "20px";
    clearDataLabel.style.color = "#ff5555";
    clearDataLabel.textContent = "清除游戏数据";
    clearDataOption.appendChild(clearDataLabel);
    
    const clearDataButton = document.createElement('button');
    clearDataButton.style.padding = "8px 15px";
    clearDataButton.style.backgroundColor = "#660000";
    clearDataButton.style.color = "#ffffff";
    clearDataButton.style.border = "1px solid #ff0000";
    clearDataButton.style.borderRadius = "5px";
    clearDataButton.style.cursor = "pointer";
    clearDataButton.textContent = "清除数据";
    
    clearDataButton.addEventListener('click', () => {
        if (confirm("确定要清除所有游戏数据吗？这将重置高分、成就和符卡记录。")) {
            localStorage.removeItem('highScore');
            localStorage.removeItem('achievements');
            localStorage.removeItem('spellHistory');
            
            GAME_STATE.highScore = 0;
            GAME_STATE.achievements = {};
            GAME_STATE.spellHistory = {};
            
            ACHIEVEMENTS.forEach(achievement => {
                GAME_STATE.achievements[achievement.id] = { 
                    unlocked: false, 
                    progress: 0, 
                    date: null 
                };
            });
            
            alert("游戏数据已清除！");
        }
    });
    
    clearDataOption.appendChild(clearDataButton);
    optionsList.appendChild(clearDataOption);
    
    optionsMenu.appendChild(optionsList);
    
    // 返回按钮
    const backButton = document.createElement('div');
    backButton.style.fontSize = "18px";
    backButton.style.padding = "10px 20px";
    backButton.style.backgroundColor = "#222";
    backButton.style.border = "1px solid #666";
    backButton.style.cursor = "pointer";
    backButton.style.transition = "all 0.3s";
    backButton.textContent = "返回主菜单";
    
    backButton.addEventListener('mouseover', () => {
        backButton.style.backgroundColor = "#444";
        backButton.style.boxShadow = "0 0 15px #88f";
            });
            
            backButton.addEventListener('mouseout', () => {
                backButton.style.backgroundColor = "#222";
                backButton.style.transform = "scale(1)";
                backButton.style.boxShadow = "none";
            });
            
            backButton.addEventListener('click', () => {
                optionsMenu.remove();
                menu.style.display = "flex";
            });
            
            optionsMenu.appendChild(backButton);
            
            document.getElementById('game-container').appendChild(optionsMenu);
        }
        
        // 检查成就
        function checkAchievements() {
            // 检查各种成就条件
            
            // 擦弹大师
            if (GAME_STATE.graze >= 1000) {
                checkAchievement("graze_master", 1);
            }
            
            // 高分达人
            if (GAME_STATE.score >= 1000000) {
                checkAchievement("high_score", 1);
            }
            
            // 连击之王
            if (GAME_STATE.combo >= 100) {
                checkAchievement("combo_king", 1);
            }
            
            // 无炸无伤（游戏通关时检查）
            // 一命通关（游戏通关时检查）
        }
        
        // 检查和更新特定成就
        function checkAchievement(achievementId, progress) {
            const achievement = GAME_STATE.achievements[achievementId];
            
            if (achievement && !achievement.unlocked) {
                // 更新进度
                achievement.progress = Math.min(1, achievement.progress + progress);
                
                // 如果进度达到100%，解锁成就
                if (achievement.progress >= 1) {
                    achievement.unlocked = true;
                    achievement.date = new Date().toISOString();
                    
                    // 显示成就解锁通知
                    showAchievementUnlocked(achievementId);
                }
                
                // 保存成就
                localStorage.setItem('achievements', JSON.stringify(GAME_STATE.achievements));
            }
        }
        
        // 显示成就解锁通知
        function showAchievementUnlocked(achievementId) {
            const achievement = ACHIEVEMENTS.find(a => a.id === achievementId);
            
            if (!achievement) return;
            
            // 创建通知元素
            const notification = document.createElement('div');
            notification.style.position = "absolute";
            notification.style.bottom = "-100px"; // 开始于屏幕外
            notification.style.left = "50%";
            notification.style.transform = "translateX(-50%)";
            notification.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
            notification.style.border = "2px solid #88ff88";
            notification.style.borderRadius = "10px";
            notification.style.padding = "15px 25px";
            notification.style.display = "flex";
            notification.style.flexDirection = "column";
            notification.style.alignItems = "center";
            notification.style.transition = "bottom 0.5s ease-out";
            notification.style.zIndex = "100";
            
            // 成就标题
            const title = document.createElement('div');
            title.style.fontSize = "18px";
            title.style.color = "#88ff88";
            title.style.fontWeight = "bold";
            title.style.marginBottom = "5px";
            title.textContent = "成就解锁！";
            notification.appendChild(title);
            
            // 成就名称
            const name = document.createElement('div');
            name.style.fontSize = "20px";
            name.style.color = "#ffffff";
            name.textContent = achievement.name;
            notification.appendChild(name);
            
            // 成就描述
            const desc = document.createElement('div');
            desc.style.fontSize = "14px";
            desc.style.color = "#aaaaaa";
            desc.style.marginTop = "5px";
            desc.textContent = achievement.description;
            notification.appendChild(desc);
            
            // 添加到页面
            document.getElementById('game-container').appendChild(notification);
            
            // 动画效果
            setTimeout(() => {
                notification.style.bottom = "20px";
            }, 100);
            
            // 自动消失
            setTimeout(() => {
                notification.style.bottom = "-100px";
                
                // 移除元素
                setTimeout(() => {
                    notification.remove();
                }, 500);
            }, 5000);
        }
        
        // 保存回放帧
        function saveReplayFrame() {
            if (GAME_STATE.replayMode) return; // 回放模式下不记录
            
            // 记录当前游戏状态的快照
            const frame = {
                stageTimer: GAME_STATE.stageTimer,
                playerPosition: player ? { x: player.x, y: player.y } : null,
                playerIsFocused: player ? player.isFocused : false,
                keys: { ...KEYS },
                score: GAME_STATE.score,
                lives: GAME_STATE.lives,
                bombs: GAME_STATE.bombs,
                power: GAME_STATE.power,
                graze: GAME_STATE.graze
            };
            
            GAME_STATE.replayData.push(frame);
            
            // 限制回放数据大小
            if (GAME_STATE.replayData.length > 10000) {
                GAME_STATE.replayData.shift();
            }
        }
        
        // 播放回放
        function playReplay(replayData) {
            if (!replayData || replayData.length === 0) return;
            
            // 设置回放模式
            GAME_STATE.replayMode = true;
            GAME_STATE.currentReplay = replayData;
            GAME_STATE.replayFrame = 0;
            
            // 重置游戏状态
            GAME_STATE.isRunning = true;
            GAME_STATE.isPaused = false;
            GAME_STATE.isGameOver = false;
            GAME_STATE.currentStage = 0;
            
            // 隐藏菜单
            menu.style.display = "none";
            
            // 创建玩家
            player = new Player(GAME_STATE.selectedCharacter);
            
            // 清空所有实体
            playerBullets = [];
            enemies = [];
            bosses = [];
            enemyBullets = [];
            items = [];
            effects = [];
            
            // 开始游戏循环
            startGameLoop();
            
            // 加载第一关
            loadStage(0);
        }
        
        // 更新回放
        function updateReplay() {
            if (!GAME_STATE.replayMode || !GAME_STATE.currentReplay) return;
            
            // 获取当前帧
            const frame = GAME_STATE.currentReplay[GAME_STATE.replayFrame];
            
            if (frame) {
                // 更新键盘状态
                KEYS.up = frame.keys.up;
                KEYS.down = frame.keys.down;
                KEYS.left = frame.keys.left;
                KEYS.right = frame.keys.right;
                KEYS.shoot = frame.keys.shoot;
                KEYS.focus = frame.keys.focus;
                KEYS.bomb = frame.keys.bomb;
                KEYS.special = frame.keys.special;
                
                // 更新玩家状态
                if (player && frame.playerPosition) {
                    player.x = frame.playerPosition.x;
                    player.y = frame.playerPosition.y;
                    player.isFocused = frame.playerIsFocused;
                }
                
                // 更新游戏状态
                GAME_STATE.score = frame.score;
                GAME_STATE.lives = frame.lives;
                GAME_STATE.bombs = frame.bombs;
                GAME_STATE.power = frame.power;
                GAME_STATE.graze = frame.graze;
                
                // 前进到下一帧
                GAME_STATE.replayFrame += 1;
                
                // 检查回放是否结束
                if (GAME_STATE.replayFrame >= GAME_STATE.currentReplay.length) {
                    // 回放结束，返回菜单
                    GAME_STATE.replayMode = false;
                    goBackToMenu();
                }
            }
        }
        
        // 初始化游戏
        initGame();
    </script>
</body>
</html>